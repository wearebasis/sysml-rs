//! Parallel state machine runner for composite state machines with concurrent regions.

use std::collections::{HashMap, VecDeque};
use sysml_core::ModelGraph;
use sysml_run::{ActionIR, AssignmentOp, ParallelStepResult, StateMachineIR};
use sysml_span::Diagnostic;

/// Runner for parallel/composite state machines with multiple concurrent regions.
///
/// Supports:
/// - Multiple concurrent regions executing independently
/// - Internal event queue for cross-region communication via `send()`
/// - Timing context variables (e.g., `t_ms`) updated by structured actions
/// - Run-to-completion semantics (drains event queue before returning)
pub struct ParallelStateMachineRunner {
    ir: StateMachineIR,
    /// Current state of each region (region name -> state name).
    region_states: HashMap<String, String>,
    /// Internal event queue for cross-region communication.
    event_queue: VecDeque<String>,
    /// Context variables (timing parameters, etc.).
    context: HashMap<String, f64>,
    /// Whether execution has completed.
    completed: bool,
}

impl ParallelStateMachineRunner {
    /// Create a new parallel runner from IR.
    pub fn new(ir: StateMachineIR) -> Self {
        let mut region_states = HashMap::new();

        // Initialize each region to its initial state
        for region in &ir.regions {
            region_states.insert(region.name.clone(), region.initial.clone());
        }

        ParallelStateMachineRunner {
            ir,
            region_states,
            event_queue: VecDeque::new(),
            context: HashMap::new(),
            completed: false,
        }
    }

    /// Create a runner by compiling a model graph.
    pub fn from_graph(graph: &ModelGraph) -> Result<Self, Vec<Diagnostic>> {
        use crate::StateMachineCompiler;
        use sysml_run::CompileToIR;

        let ir = StateMachineCompiler::compile(graph)?;
        Ok(Self::new(ir))
    }

    /// Set initial context values.
    pub fn with_context(mut self, ctx: HashMap<String, f64>) -> Self {
        self.context = ctx;
        self
    }

    /// Set a single context variable.
    pub fn set_context(&mut self, name: impl Into<String>, value: f64) {
        self.context.insert(name.into(), value);
    }

    /// Get a context variable value.
    pub fn get_context(&self, name: &str) -> Option<f64> {
        self.context.get(name).copied()
    }

    /// Get the current simulation time (t_ms context variable).
    pub fn t_ms(&self) -> f64 {
        self.context.get("t_ms").copied().unwrap_or(0.0)
    }

    /// Get the state of a specific region.
    pub fn region_state(&self, region: &str) -> Option<&str> {
        self.region_states.get(region).map(|s| s.as_str())
    }

    /// Get all region states.
    pub fn region_states(&self) -> &HashMap<String, String> {
        &self.region_states
    }

    /// Check if execution has completed.
    pub fn is_completed(&self) -> bool {
        self.completed
    }

    /// Reset the runner to initial states.
    pub fn reset(&mut self) {
        self.region_states.clear();
        for region in &self.ir.regions {
            self.region_states
                .insert(region.name.clone(), region.initial.clone());
        }
        self.event_queue.clear();
        self.context.clear();
        self.completed = false;
    }

    /// Send an external event and execute until stable.
    ///
    /// This is the primary way to interact with the state machine.
    /// The event is queued and processed, along with any internal events
    /// generated by `send()` actions, until the queue is empty.
    pub fn send(&mut self, event: &str) -> ParallelStepResult {
        self.event_queue.push_back(event.to_string());
        self.execute_until_stable()
    }

    /// Execute until the event queue is empty (run-to-completion).
    fn execute_until_stable(&mut self) -> ParallelStepResult {
        let mut result = ParallelStepResult::new();
        let mut all_internal_events = Vec::new();

        while let Some(event) = self.event_queue.pop_front() {
            let step_result = self.process_event(&event);
            result.outputs.extend(step_result.outputs);
            all_internal_events.extend(step_result.internal_events.clone());

            // Queue any internal events generated by this step
            for internal_event in step_result.internal_events {
                self.event_queue.push_back(internal_event);
            }
        }

        // Build final result
        result.region_states = self.region_states.clone();
        result.internal_events = all_internal_events;
        result.context = self.context.clone();
        result.completed = self.check_completion();
        self.completed = result.completed;

        result
    }

    /// Process a single event across all regions.
    fn process_event(&mut self, event: &str) -> ParallelStepResult {
        let mut result = ParallelStepResult::new();
        let mut generated_events = Vec::new();

        // Collect all transitions that need to be executed
        // (region_name, exit_action, transition_action, new_state, entry_action)
        let mut transitions_to_execute: Vec<(
            String,
            Option<ActionIR>,
            Option<ActionIR>,
            String,
            Option<ActionIR>,
        )> = Vec::new();

        // First pass: find all matching transitions (immutable borrow of self.ir)
        for region in &self.ir.regions {
            if let Some(current_state) = self.region_states.get(&region.name).cloned() {
                let transitions = region.transitions_from(&current_state);
                let matching = transitions.iter().find(|t| t.matches(Some(event)));

                if let Some(transition) = matching {
                    let exit_action = region
                        .find_state(&current_state)
                        .and_then(|s| s.exit_action.clone());
                    let transition_action = transition.action.clone();
                    let new_state = transition.to.clone();
                    let entry_action = region
                        .find_state(&transition.to)
                        .and_then(|s| s.entry_action.clone());

                    transitions_to_execute.push((
                        region.name.clone(),
                        exit_action,
                        transition_action,
                        new_state,
                        entry_action,
                    ));
                }
            }
        }

        // Second pass: execute all transitions (mutable borrow of self)
        for (region_name, exit_action, transition_action, new_state, entry_action) in
            transitions_to_execute
        {
            // Execute exit action
            if let Some(action) = exit_action {
                let (outputs, events) = Self::execute_action(&mut self.context, &action);
                for output in outputs {
                    result
                        .outputs
                        .push(format!("[{}] exit: {}", region_name, output));
                }
                generated_events.extend(events);
            }

            // Execute transition action
            if let Some(action) = transition_action {
                let (outputs, events) = Self::execute_action(&mut self.context, &action);
                for output in outputs {
                    result
                        .outputs
                        .push(format!("[{}] action: {}", region_name, output));
                }
                generated_events.extend(events);
            }

            // Move to new state
            self.region_states.insert(region_name.clone(), new_state);

            // Execute entry action
            if let Some(action) = entry_action {
                let (outputs, events) = Self::execute_action(&mut self.context, &action);
                for output in outputs {
                    result
                        .outputs
                        .push(format!("[{}] entry: {}", region_name, output));
                }
                generated_events.extend(events);
            }
        }

        result.region_states = self.region_states.clone();
        result.internal_events = generated_events;
        result
    }

    /// Execute an action and return any outputs and generated events.
    fn execute_action(
        context: &mut HashMap<String, f64>,
        action: &ActionIR,
    ) -> (Vec<String>, Vec<String>) {
        let mut outputs = Vec::new();
        let mut events = Vec::new();

        match action {
            ActionIR::Simple(s) => {
                outputs.push(s.clone());
            }
            ActionIR::Structured { assignments, sends } => {
                // Execute assignments
                for assign in assignments {
                    let current = context.get(&assign.variable).copied().unwrap_or(0.0);
                    let new_value = match assign.operator {
                        AssignmentOp::Set => assign.value,
                        AssignmentOp::Add => current + assign.value,
                        AssignmentOp::Subtract => current - assign.value,
                    };
                    context.insert(assign.variable.clone(), new_value);
                    outputs.push(format!(
                        "{} {} {}",
                        assign.variable,
                        match assign.operator {
                            AssignmentOp::Set => "=",
                            AssignmentOp::Add => "+=",
                            AssignmentOp::Subtract => "-=",
                        },
                        assign.value
                    ));
                }

                // Collect send events
                for send in sends {
                    events.push(send.clone());
                    outputs.push(format!("send('{}')", send));
                }
            }
        }

        (outputs, events)
    }

    /// Check if all regions are in final states.
    fn check_completion(&self) -> bool {
        for region in &self.ir.regions {
            if let Some(current_state) = self.region_states.get(&region.name) {
                if let Some(state) = region.find_state(current_state) {
                    if !state.is_final {
                        return false;
                    }
                }
            }
        }
        // Only mark completed if there are regions and all are in final states
        !self.ir.regions.is_empty()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sysml_run::{AssignmentIR, RegionIR, StateIR, TransitionIR};

    fn create_simple_parallel_ir() -> StateMachineIR {
        StateMachineIR::parallel("TestParallel")
            .with_region(
                RegionIR::new("regionA", "A1")
                    .with_state(StateIR::new("A1"))
                    .with_state(StateIR::new("A2"))
                    .with_transition(TransitionIR::new("A1", "A2").with_event("go")),
            )
            .with_region(
                RegionIR::new("regionB", "B1")
                    .with_state(StateIR::new("B1"))
                    .with_state(StateIR::new("B2"))
                    .with_transition(TransitionIR::new("B1", "B2").with_event("go")),
            )
    }

    #[test]
    fn parallel_regions_initialize() {
        let ir = create_simple_parallel_ir();
        let runner = ParallelStateMachineRunner::new(ir);

        assert_eq!(runner.region_state("regionA"), Some("A1"));
        assert_eq!(runner.region_state("regionB"), Some("B1"));
    }

    #[test]
    fn parallel_regions_step() {
        let ir = create_simple_parallel_ir();
        let mut runner = ParallelStateMachineRunner::new(ir);

        let result = runner.send("go");

        assert_eq!(result.region_states.get("regionA"), Some(&"A2".to_string()));
        assert_eq!(result.region_states.get("regionB"), Some(&"B2".to_string()));
    }

    #[test]
    fn internal_events_cross_region() {
        // Region A sends an event that triggers region B
        let ir = StateMachineIR::parallel("CrossRegion")
            .with_region(
                RegionIR::new("regionA", "A1")
                    .with_state(StateIR::new("A1"))
                    .with_state(
                        StateIR::new("A2").with_entry_action(ActionIR::structured(
                            vec![],
                            vec!["triggerB".to_string()],
                        )),
                    )
                    .with_transition(TransitionIR::new("A1", "A2").with_event("start")),
            )
            .with_region(
                RegionIR::new("regionB", "B1")
                    .with_state(StateIR::new("B1"))
                    .with_state(StateIR::new("B2"))
                    .with_transition(TransitionIR::new("B1", "B2").with_event("triggerB")),
            );

        let mut runner = ParallelStateMachineRunner::new(ir);

        // Send "start" which should transition A1->A2, which sends "triggerB", which transitions B1->B2
        let result = runner.send("start");

        assert_eq!(result.region_states.get("regionA"), Some(&"A2".to_string()));
        assert_eq!(result.region_states.get("regionB"), Some(&"B2".to_string()));
        assert!(result.internal_events.contains(&"triggerB".to_string()));
    }

    #[test]
    fn timing_context_updates() {
        let ir = StateMachineIR::parallel("TimingTest")
            .with_region(
                RegionIR::new("timer", "waiting")
                    .with_state(StateIR::new("waiting"))
                    .with_state(
                        StateIR::new("processing").with_entry_action(ActionIR::structured(
                            vec![AssignmentIR::add("t_ms", 10.0)],
                            vec![],
                        )),
                    )
                    .with_transition(TransitionIR::new("waiting", "processing").with_event("tick")),
            );

        let mut runner = ParallelStateMachineRunner::new(ir);
        runner.set_context("t_ms", 0.0);

        let result = runner.send("tick");

        assert_eq!(result.context.get("t_ms"), Some(&10.0));
        assert_eq!(runner.t_ms(), 10.0);
    }

    #[test]
    fn execute_until_stable() {
        // Chain of events: start -> A sends triggerB -> B sends triggerC -> C transitions
        let ir = StateMachineIR::parallel("ChainTest")
            .with_region(
                RegionIR::new("regionA", "A1")
                    .with_state(StateIR::new("A1"))
                    .with_state(
                        StateIR::new("A2").with_entry_action(ActionIR::structured(
                            vec![],
                            vec!["triggerB".to_string()],
                        )),
                    )
                    .with_transition(TransitionIR::new("A1", "A2").with_event("start")),
            )
            .with_region(
                RegionIR::new("regionB", "B1")
                    .with_state(StateIR::new("B1"))
                    .with_state(
                        StateIR::new("B2").with_entry_action(ActionIR::structured(
                            vec![],
                            vec!["triggerC".to_string()],
                        )),
                    )
                    .with_transition(TransitionIR::new("B1", "B2").with_event("triggerB")),
            )
            .with_region(
                RegionIR::new("regionC", "C1")
                    .with_state(StateIR::new("C1"))
                    .with_state(StateIR::new("C2"))
                    .with_transition(TransitionIR::new("C1", "C2").with_event("triggerC")),
            );

        let mut runner = ParallelStateMachineRunner::new(ir);

        // Single "start" event should cascade through all regions
        let result = runner.send("start");

        assert_eq!(result.region_states.get("regionA"), Some(&"A2".to_string()));
        assert_eq!(result.region_states.get("regionB"), Some(&"B2".to_string()));
        assert_eq!(result.region_states.get("regionC"), Some(&"C2".to_string()));
    }

    #[test]
    fn backward_compat_simple() {
        // A parallel runner with no regions should still work (no-op)
        let ir = StateMachineIR::parallel("Empty");
        let mut runner = ParallelStateMachineRunner::new(ir);

        let result = runner.send("anything");
        assert!(result.region_states.is_empty());
    }

    #[test]
    fn reset_runner() {
        let ir = create_simple_parallel_ir();
        let mut runner = ParallelStateMachineRunner::new(ir);

        runner.send("go");
        assert_eq!(runner.region_state("regionA"), Some("A2"));

        runner.reset();
        assert_eq!(runner.region_state("regionA"), Some("A1"));
        assert_eq!(runner.region_state("regionB"), Some("B1"));
    }

    #[test]
    fn context_manipulation() {
        let ir = StateMachineIR::parallel("ContextTest");
        let mut runner = ParallelStateMachineRunner::new(ir);

        runner.set_context("sensor_time", 15.0);
        runner.set_context("relay_time", 20.0);

        assert_eq!(runner.get_context("sensor_time"), Some(15.0));
        assert_eq!(runner.get_context("relay_time"), Some(20.0));
        assert_eq!(runner.get_context("unknown"), None);
    }
}
