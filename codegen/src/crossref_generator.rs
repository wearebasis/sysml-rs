//! Cross-reference registry code generator.
//!
//! This module generates Rust code that documents all cross-reference properties
//! extracted from the Xtext grammar, including their target types and scoping strategies.
//!
//! ## Generated File
//!
//! The generator produces `crossrefs.generated.rs` which contains:
//! - `CrossRefSpec` struct - metadata for each cross-reference
//! - `ScopeStrategy` enum - scoping strategies
//! - `ALL_CROSS_REFERENCES` constant - registry of all cross-references
//! - Helper functions for looking up properties

use crate::crossref_validation::{infer_scope_strategy, ScopeStrategy};
use crate::xtext_crossref_parser::CrossReference;

/// Generate the cross-reference registry Rust code.
///
/// # Arguments
///
/// * `cross_refs` - All cross-references from grammar
///
/// # Returns
///
/// Generated Rust code as a string.
pub fn generate_crossref_registry(cross_refs: &[CrossReference]) -> String {
    let mut code = String::new();

    // Header - use regular comments since this is included, not a module root
    code.push_str("// Cross-reference registry generated from Xtext grammar.\n");
    code.push_str("//\n");
    code.push_str("// This file is automatically generated by sysml-codegen.\n");
    code.push_str("// DO NOT EDIT MANUALLY.\n");
    code.push_str("//\n");
    code.push_str("// Source grammars:\n");
    code.push_str("// - KerML.xtext\n");
    code.push_str("// - SysML.xtext\n");
    code.push_str("\n");

    // ScopeStrategy enum
    code.push_str(&generate_scope_strategy_enum());
    code.push_str("\n");

    // CrossRefSpec struct
    code.push_str(&generate_crossref_spec_struct());
    code.push_str("\n");

    // ALL_CROSS_REFERENCES constant
    code.push_str(&generate_all_crossrefs_constant(cross_refs));
    code.push_str("\n");

    // Helper functions
    code.push_str(&generate_helper_functions());

    code
}

fn generate_scope_strategy_enum() -> String {
    r#"/// Scoping strategy for resolving a cross-reference.
///
/// Different cross-references require different scoping rules based on
/// the SysML v2 specification and the Xtext reference implementation.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ScopeStrategy {
    /// Resolve in the owning namespace, then walk up to parent namespaces.
    /// Most common strategy for general references.
    OwningNamespace,
    /// Non-expression namespace - skips expression scopes.
    /// Used for FeatureTyping, Conjugation.
    NonExpressionNamespace,
    /// Relative namespace for feature chains.
    /// Scope is relative to the previous element in the chain.
    RelativeNamespace,
    /// Feature chaining - position-dependent resolution.
    /// Each position in the chain affects the next.
    FeatureChaining,
    /// Transition-specific scoping for state machine elements.
    /// Handles triggers, guards, effects in transition context.
    TransitionSpecific,
    /// Global scope - resolve from root packages.
    /// Used for imports and top-level references.
    Global,
}

impl ScopeStrategy {
    /// Get the strategy name as a string.
    pub const fn as_str(&self) -> &'static str {
        match self {
            ScopeStrategy::OwningNamespace => "owning_namespace",
            ScopeStrategy::NonExpressionNamespace => "non_expression_namespace",
            ScopeStrategy::RelativeNamespace => "relative_namespace",
            ScopeStrategy::FeatureChaining => "feature_chaining",
            ScopeStrategy::TransitionSpecific => "transition_specific",
            ScopeStrategy::Global => "global",
        }
    }
}
"#
    .to_string()
}

fn generate_crossref_spec_struct() -> String {
    r#"/// Specification for a cross-reference property.
///
/// This struct documents a cross-reference property from the grammar,
/// including what type it resolves to and how it should be scoped.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CrossRefSpec {
    /// The property name (e.g., "general", "type").
    pub property: &'static str,
    /// The target type (e.g., "Type", "Feature", "Element").
    pub target_type: &'static str,
    /// The scoping strategy to use.
    pub scope: ScopeStrategy,
    /// Whether this is a multi-valued reference.
    pub is_multi: bool,
    /// The containing grammar rule.
    pub containing_rule: &'static str,
}

impl CrossRefSpec {
    /// Get the unresolved property name used in Element::props.
    ///
    /// Convention: `unresolved_{property_name}`
    pub const fn unresolved_prop(&self) -> &'static str {
        // Note: This returns the property name; the actual unresolved_*
        // name is constructed at resolution time
        self.property
    }
}
"#
    .to_string()
}

fn generate_all_crossrefs_constant(cross_refs: &[CrossReference]) -> String {
    let mut code = String::new();

    code.push_str("/// All cross-reference properties extracted from the Xtext grammar.\n");
    code.push_str("///\n");
    code.push_str(&format!(
        "/// Total: {} cross-references\n",
        cross_refs.len()
    ));
    code.push_str("pub const ALL_CROSS_REFERENCES: &[CrossRefSpec] = &[\n");

    // Group by target type for readability
    let mut by_target: std::collections::BTreeMap<String, Vec<&CrossReference>> =
        std::collections::BTreeMap::new();
    for cr in cross_refs {
        by_target
            .entry(cr.target_type.clone())
            .or_default()
            .push(cr);
    }

    for (target_type, refs) in &by_target {
        code.push_str(&format!("    // Target: {}\n", target_type));

        for cr in refs {
            let strategy = infer_scope_strategy(cr);
            code.push_str(&format!(
                "    CrossRefSpec {{ property: \"{}\", target_type: \"{}\", scope: ScopeStrategy::{}, is_multi: {}, containing_rule: \"{}\" }},\n",
                cr.property,
                cr.target_type,
                scope_strategy_to_variant(&strategy),
                cr.is_multi,
                cr.containing_rule
            ));
        }
    }

    code.push_str("];\n");

    code
}

fn scope_strategy_to_variant(strategy: &ScopeStrategy) -> &'static str {
    match strategy {
        ScopeStrategy::OwningNamespace => "OwningNamespace",
        ScopeStrategy::NonExpressionNamespace => "NonExpressionNamespace",
        ScopeStrategy::RelativeNamespace => "RelativeNamespace",
        ScopeStrategy::FeatureChaining => "FeatureChaining",
        ScopeStrategy::TransitionSpecific => "TransitionSpecific",
        ScopeStrategy::Global => "Global",
    }
}

fn generate_helper_functions() -> String {
    r#"/// Find a cross-reference spec by property name.
pub fn find_crossref_spec(property: &str) -> Option<&'static CrossRefSpec> {
    ALL_CROSS_REFERENCES
        .iter()
        .find(|spec| spec.property == property)
}

/// Get all cross-references that target a specific type.
pub fn crossrefs_for_target(target_type: &str) -> impl Iterator<Item = &'static CrossRefSpec> + '_ {
    ALL_CROSS_REFERENCES
        .iter()
        .filter(move |spec| spec.target_type == target_type)
}

/// Get all cross-references that use a specific scoping strategy.
pub fn crossrefs_for_strategy(strategy: ScopeStrategy) -> impl Iterator<Item = &'static CrossRefSpec> {
    ALL_CROSS_REFERENCES
        .iter()
        .filter(move |spec| spec.scope == strategy)
}

/// Get all property names as a slice.
pub fn all_crossref_properties() -> impl Iterator<Item = &'static str> {
    ALL_CROSS_REFERENCES.iter().map(|spec| spec.property)
}

/// Check if a property name is a known cross-reference.
pub fn is_crossref_property(property: &str) -> bool {
    find_crossref_spec(property).is_some()
}

/// Get statistics about cross-references.
pub fn crossref_stats() -> CrossRefStats {
    let mut by_strategy = [0usize; 6];
    let mut by_target: std::collections::HashMap<&str, usize> = std::collections::HashMap::new();
    let mut multi_count = 0;

    for spec in ALL_CROSS_REFERENCES {
        let idx = match spec.scope {
            ScopeStrategy::OwningNamespace => 0,
            ScopeStrategy::NonExpressionNamespace => 1,
            ScopeStrategy::RelativeNamespace => 2,
            ScopeStrategy::FeatureChaining => 3,
            ScopeStrategy::TransitionSpecific => 4,
            ScopeStrategy::Global => 5,
        };
        by_strategy[idx] += 1;

        *by_target.entry(spec.target_type).or_default() += 1;

        if spec.is_multi {
            multi_count += 1;
        }
    }

    CrossRefStats {
        total: ALL_CROSS_REFERENCES.len(),
        multi_valued: multi_count,
        by_strategy,
    }
}

/// Statistics about cross-references.
#[derive(Debug, Clone)]
pub struct CrossRefStats {
    /// Total number of cross-references.
    pub total: usize,
    /// Number of multi-valued references.
    pub multi_valued: usize,
    /// Count by strategy: [OwningNs, NonExprNs, RelativeNs, Chaining, Transition, Global]
    pub by_strategy: [usize; 6],
}
"#
    .to_string()
}

/// Generate a summary comment for the registry.
pub fn generate_summary(cross_refs: &[CrossReference]) -> String {
    let mut summary = String::new();

    summary.push_str("Cross-Reference Registry Summary\n");
    summary.push_str("================================\n\n");

    // By target type
    let mut by_target: std::collections::BTreeMap<&str, Vec<&str>> =
        std::collections::BTreeMap::new();
    for cr in cross_refs {
        by_target
            .entry(&cr.target_type)
            .or_default()
            .push(&cr.property);
    }

    summary.push_str("By Target Type:\n");
    for (target, props) in &by_target {
        summary.push_str(&format!("  {}: {:?}\n", target, props));
    }

    // By strategy
    let mut by_strategy: std::collections::BTreeMap<String, Vec<&str>> =
        std::collections::BTreeMap::new();
    for cr in cross_refs {
        let strategy = infer_scope_strategy(cr);
        by_strategy
            .entry(strategy.as_str().to_string())
            .or_default()
            .push(&cr.property);
    }

    summary.push_str("\nBy Scoping Strategy:\n");
    for (strategy, props) in &by_strategy {
        summary.push_str(&format!("  {}: {:?}\n", strategy, props));
    }

    summary.push_str(&format!("\nTotal: {} cross-references\n", cross_refs.len()));

    summary
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_crossref(property: &str, target: &str, rule: &str) -> CrossReference {
        CrossReference {
            property: property.to_string(),
            target_type: target.to_string(),
            namespace: "SysML".to_string(),
            reference_name: "QualifiedName".to_string(),
            containing_rule: rule.to_string(),
            is_multi: false,
            source_file: "test.xtext".to_string(),
            line_number: 1,
        }
    }

    #[test]
    fn test_generate_crossref_registry() {
        let refs = vec![
            make_crossref("general", "Type", "Specialization"),
            make_crossref("type", "Type", "FeatureTyping"),
            make_crossref("subsettedFeature", "Feature", "Subsetting"),
        ];

        let code = generate_crossref_registry(&refs);

        // Check for key components
        assert!(code.contains("pub enum ScopeStrategy"));
        assert!(code.contains("pub struct CrossRefSpec"));
        assert!(code.contains("pub const ALL_CROSS_REFERENCES"));
        assert!(code.contains("\"general\""));
        assert!(code.contains("\"type\""));
        assert!(code.contains("\"subsettedFeature\""));
    }

    #[test]
    fn test_generate_summary() {
        let refs = vec![
            make_crossref("general", "Type", "Specialization"),
            make_crossref("type", "Type", "FeatureTyping"),
        ];

        let summary = generate_summary(&refs);

        assert!(summary.contains("By Target Type:"));
        assert!(summary.contains("Type:"));
        assert!(summary.contains("Total: 2"));
    }
}
