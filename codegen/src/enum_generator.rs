//! Rust enum code generator from type information.
//!
//! This module generates Rust enum definitions from parsed TTL type information.

use crate::ttl_parser::TypeInfo;

/// Generate a Rust enum from type information.
///
/// # Arguments
///
/// * `enum_name` - The name of the enum to generate (e.g., "ElementKind")
/// * `kerml_types` - Types from the KerML vocabulary
/// * `sysml_types` - Types from the SysML vocabulary
///
/// # Returns
///
/// A string containing the generated Rust code.
///
/// # Examples
///
/// ```
/// use sysml_codegen::ttl_parser::TypeInfo;
/// use sysml_codegen::enum_generator::generate_enum;
///
/// let kerml = vec![TypeInfo {
///     name: "Element".to_string(),
///     supertypes: vec!["Resource".to_string()],
///     comment: Some("Base element type.".to_string()),
/// }];
/// let sysml = vec![TypeInfo {
///     name: "PartUsage".to_string(),
///     supertypes: vec!["Usage".to_string()],
///     comment: None,
/// }];
///
/// let code = generate_enum("ElementKind", &kerml, &sysml);
/// assert!(code.contains("pub enum ElementKind"));
/// assert!(code.contains("Element,"));
/// assert!(code.contains("PartUsage,"));
/// ```
pub fn generate_enum(enum_name: &str, kerml_types: &[TypeInfo], sysml_types: &[TypeInfo]) -> String {
    let mut output = String::new();

    // File header
    output.push_str("// This file is automatically generated by sysml-codegen.\n");
    output.push_str("// Do not edit manually.\n");
    output.push_str("//\n");
    output.push_str(&format!(
        "// Generated from KerML ({} types) and SysML ({} types) vocabularies.\n",
        kerml_types.len(),
        sysml_types.len()
    ));
    output.push_str("\n");

    // Enum definition
    output.push_str("/// The kind of a model element, generated from SysML v2 specification vocabularies.\n");
    output.push_str("///\n");
    output.push_str(&format!(
        "/// This enum contains {} KerML types and {} SysML types ({} total).\n",
        kerml_types.len(),
        sysml_types.len(),
        kerml_types.len() + sysml_types.len()
    ));
    output.push_str("#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n");
    output.push_str("#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n");
    output.push_str("#[cfg_attr(feature = \"serde\", serde(rename_all = \"PascalCase\"))]\n");
    output.push_str("#[non_exhaustive]\n");
    output.push_str(&format!("pub enum {} {{\n", enum_name));

    // KerML types section
    output.push_str("    // === KerML Types ===\n");
    for type_info in kerml_types {
        if let Some(comment) = &type_info.comment {
            // Truncate long comments
            let short_comment = if comment.len() > 100 {
                format!("{}...", &comment[..100])
            } else {
                comment.clone()
            };
            output.push_str(&format!("    /// {}\n", short_comment.replace('\n', " ")));
        }
        output.push_str(&format!("    {},\n", type_info.name));
    }

    // SysML types section
    output.push_str("\n    // === SysML Types ===\n");
    for type_info in sysml_types {
        // Skip types that are already in KerML (duplicates)
        if kerml_types.iter().any(|t| t.name == type_info.name) {
            continue;
        }
        if let Some(comment) = &type_info.comment {
            let short_comment = if comment.len() > 100 {
                format!("{}...", &comment[..100])
            } else {
                comment.clone()
            };
            output.push_str(&format!("    /// {}\n", short_comment.replace('\n', " ")));
        }
        output.push_str(&format!("    {},\n", type_info.name));
    }

    output.push_str("}\n\n");

    // Generate impl block
    generate_impl_block(&mut output, enum_name, kerml_types, sysml_types);

    // Generate Default impl
    output.push_str(&format!("impl Default for {} {{\n", enum_name));
    output.push_str("    fn default() -> Self {\n");
    output.push_str(&format!("        {}::Element\n", enum_name));
    output.push_str("    }\n");
    output.push_str("}\n\n");

    // Generate Display impl
    output.push_str(&format!("impl std::fmt::Display for {} {{\n", enum_name));
    output.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    output.push_str("        write!(f, \"{}\", self.as_str())\n");
    output.push_str("    }\n");
    output.push_str("}\n");

    output
}

fn generate_impl_block(output: &mut String, enum_name: &str, kerml_types: &[TypeInfo], sysml_types: &[TypeInfo]) {
    // Collect all unique type names
    let mut all_names: Vec<&str> = kerml_types.iter().map(|t| t.name.as_str()).collect();
    for t in sysml_types {
        if !all_names.contains(&t.name.as_str()) {
            all_names.push(&t.name);
        }
    }
    all_names.sort();

    output.push_str(&format!("impl {} {{\n", enum_name));

    // iter() method
    output.push_str("    /// Returns an iterator over all element kinds.\n");
    output.push_str("    ///\n");
    output.push_str("    /// # Examples\n");
    output.push_str("    ///\n");
    output.push_str("    /// ```\n");
    output.push_str(&format!("    /// use sysml_core::{};\n", enum_name));
    output.push_str("    ///\n");
    output.push_str(&format!("    /// let count = {}::iter().count();\n", enum_name));
    output.push_str(&format!("    /// assert!(count > 100); // Has many unique types from KerML and SysML\n"));
    output.push_str("    /// ```\n");
    output.push_str(&format!(
        "    pub fn iter() -> impl Iterator<Item = {}> {{\n",
        enum_name
    ));
    output.push_str("        [\n");
    for name in &all_names {
        output.push_str(&format!("            {}::{},\n", enum_name, name));
    }
    output.push_str("        ].into_iter()\n");
    output.push_str("    }\n\n");

    // as_str() method
    output.push_str("    /// Returns the string representation of this element kind.\n");
    output.push_str("    ///\n");
    output.push_str("    /// # Examples\n");
    output.push_str("    ///\n");
    output.push_str("    /// ```\n");
    output.push_str(&format!("    /// use sysml_core::{};\n", enum_name));
    output.push_str("    ///\n");
    output.push_str(&format!(
        "    /// assert_eq!({}::Element.as_str(), \"Element\");\n",
        enum_name
    ));
    output.push_str(&format!(
        "    /// assert_eq!({}::PartUsage.as_str(), \"PartUsage\");\n",
        enum_name
    ));
    output.push_str("    /// ```\n");
    output.push_str("    pub fn as_str(&self) -> &'static str {\n");
    output.push_str("        match self {\n");
    for name in &all_names {
        output.push_str(&format!("            {}::{} => \"{}\",\n", enum_name, name, name));
    }
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // from_str() method
    output.push_str("    /// Parses an element kind from a string.\n");
    output.push_str("    ///\n");
    output.push_str("    /// Returns `None` if the string doesn't match any known element kind.\n");
    output.push_str("    ///\n");
    output.push_str("    /// # Examples\n");
    output.push_str("    ///\n");
    output.push_str("    /// ```\n");
    output.push_str(&format!("    /// use sysml_core::{};\n", enum_name));
    output.push_str("    ///\n");
    output.push_str(&format!(
        "    /// assert_eq!({}::from_str(\"Element\"), Some({}::Element));\n",
        enum_name, enum_name
    ));
    output.push_str(&format!(
        "    /// assert_eq!({}::from_str(\"Unknown\"), None);\n",
        enum_name
    ));
    output.push_str("    /// ```\n");
    output.push_str("    pub fn from_str(s: &str) -> Option<Self> {\n");
    output.push_str("        match s {\n");
    for name in &all_names {
        output.push_str(&format!("            \"{}\" => Some({}::{}),\n", name, enum_name, name));
    }
    output.push_str("            _ => None,\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // count() method
    output.push_str("    /// Returns the total number of element kinds.\n");
    output.push_str("    ///\n");
    output.push_str("    /// # Examples\n");
    output.push_str("    ///\n");
    output.push_str("    /// ```\n");
    output.push_str(&format!("    /// use sysml_core::{};\n", enum_name));
    output.push_str("    ///\n");
    output.push_str(&format!(
        "    /// assert_eq!({}::count(), {});\n",
        enum_name,
        all_names.len()
    ));
    output.push_str("    /// ```\n");
    output.push_str("    pub const fn count() -> usize {\n");
    output.push_str(&format!("        {}\n", all_names.len()));
    output.push_str("    }\n");

    output.push_str("}\n\n");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_basic_enum() {
        let kerml = vec![TypeInfo {
            name: "Element".to_string(),
            supertypes: vec!["Resource".to_string()],
            comment: Some("Base element type.".to_string()),
        }];
        let sysml = vec![TypeInfo {
            name: "PartUsage".to_string(),
            supertypes: vec!["Usage".to_string()],
            comment: None,
        }];

        let code = generate_enum("ElementKind", &kerml, &sysml);

        assert!(code.contains("pub enum ElementKind"));
        assert!(code.contains("Element,"));
        assert!(code.contains("PartUsage,"));
        assert!(code.contains("// === KerML Types ==="));
        assert!(code.contains("// === SysML Types ==="));
        assert!(code.contains("fn as_str(&self)"));
        assert!(code.contains("fn from_str(s: &str)"));
        assert!(code.contains("fn iter()"));
    }

    #[test]
    fn skips_duplicate_types() {
        let kerml = vec![TypeInfo {
            name: "Element".to_string(),
            supertypes: vec![],
            comment: None,
        }];
        let sysml = vec![
            TypeInfo {
                name: "Element".to_string(), // Duplicate
                supertypes: vec![],
                comment: None,
            },
            TypeInfo {
                name: "PartUsage".to_string(),
                supertypes: vec![],
                comment: None,
            },
        ];

        let code = generate_enum("TestEnum", &kerml, &sysml);

        // Element should only appear once in the KerML section, not in SysML section
        // Check by looking at the section structure
        let kerml_section = code.find("// === KerML Types ===").unwrap();
        let sysml_section = code.find("// === SysML Types ===").unwrap();
        let impl_section = code.find("impl TestEnum").unwrap();

        // Get just the variant declarations (between sections, before impl)
        let variants_section = &code[kerml_section..impl_section];

        // In the KerML section (before SysML section)
        let kerml_variants = &variants_section[0..(sysml_section - kerml_section)];
        assert!(kerml_variants.contains("Element,"), "Element should be in KerML section");

        // In the SysML section (after KerML, before impl)
        let sysml_variants = &variants_section[(sysml_section - kerml_section)..];
        assert!(!sysml_variants.contains("Element,"), "Element should NOT be in SysML section");
        assert!(sysml_variants.contains("PartUsage,"), "PartUsage should be in SysML section");
    }

    #[test]
    fn includes_count_method() {
        let kerml = vec![
            TypeInfo {
                name: "A".to_string(),
                supertypes: vec![],
                comment: None,
            },
            TypeInfo {
                name: "B".to_string(),
                supertypes: vec![],
                comment: None,
            },
        ];
        let sysml = vec![TypeInfo {
            name: "C".to_string(),
            supertypes: vec![],
            comment: None,
        }];

        let code = generate_enum("TestEnum", &kerml, &sysml);
        assert!(code.contains("pub const fn count() -> usize"));
        assert!(code.contains("3")); // A, B, C
    }
}
