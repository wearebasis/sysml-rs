//! Generator for SysML/KerML value enumeration types.
//!
//! This module generates Rust enum definitions for the value enumerations
//! defined in the SysML v2 specification, such as:
//!
//! - `FeatureDirectionKind` (in, out, inout)
//! - `VisibilityKind` (public, private, protected)
//! - `PortionKind` (snapshot, timeslice)
//! - `RequirementConstraintKind` (assumption, requirement)
//! - `StateSubactionKind` (entry, do, exit)
//! - `TransitionFeatureKind` (trigger, guard, effect)
//! - `TriggerKind` (after, at, when)

use crate::ttl_parser::EnumInfo;

/// Generate Rust enum definitions for all value enumerations.
///
/// Each generated enum includes:
/// - Derives for Debug, Clone, Copy, PartialEq, Eq, Hash
/// - Optional serde support (with cfg_attr)
/// - `as_str()` method for string representation
/// - `from_str()` method for parsing
/// - `iter()` method for iteration
/// - `Display` implementation
pub fn generate_value_enums(enums: &[EnumInfo]) -> String {
    let mut output = String::new();

    // File header
    output.push_str("// This file is automatically generated by sysml-codegen.\n");
    output.push_str("// Do not edit manually.\n");
    output.push_str("//\n");
    output.push_str(&format!(
        "// Generated {} value enumeration types from SysML v2 specification.\n",
        enums.len()
    ));
    output.push_str("\n");

    for enum_info in enums {
        output.push_str(&generate_single_enum(enum_info));
        output.push_str("\n");
    }

    output
}

/// Generate a single Rust enum from EnumInfo.
fn generate_single_enum(enum_info: &EnumInfo) -> String {
    let mut output = String::new();

    let enum_name = &enum_info.name;
    let values = &enum_info.values;

    // Skip enums with no values
    if values.is_empty() {
        return output;
    }

    // Doc comment
    if let Some(comment) = &enum_info.comment {
        // Truncate long comments
        let short_comment = if comment.len() > 200 {
            format!("{}...", &comment[..200])
        } else {
            comment.clone()
        };
        output.push_str(&format!("/// {}\n", short_comment.replace('\n', " ")));
    }

    // Derives
    output.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    output.push_str("#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\n");
    output.push_str("#[cfg_attr(feature = \"serde\", serde(rename_all = \"camelCase\"))]\n");
    output.push_str(&format!("pub enum {} {{\n", enum_name));

    // Variants
    for value in values {
        if let Some(comment) = &value.comment {
            let short_comment = if comment.len() > 100 {
                format!("{}...", &comment[..100])
            } else {
                comment.clone()
            };
            output.push_str(&format!("    /// {}\n", short_comment.replace('\n', " ")));
        }
        // Convert to PascalCase for Rust enum variants
        let variant_name = to_pascal_case(&value.name);
        output.push_str(&format!("    {},\n", variant_name));
    }

    output.push_str("}\n\n");

    // Impl block
    output.push_str(&format!("impl {} {{\n", enum_name));

    // as_str() method
    output.push_str("    /// Returns the string representation of this enum value.\n");
    output.push_str("    ///\n");
    output.push_str("    /// The string matches the SysML v2 specification value.\n");
    output.push_str("    pub const fn as_str(&self) -> &'static str {\n");
    output.push_str("        match self {\n");
    for value in values {
        let variant_name = to_pascal_case(&value.name);
        output.push_str(&format!(
            "            Self::{} => \"{}\",\n",
            variant_name, value.name
        ));
    }
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // from_str() method
    output.push_str("    /// Parses a string into this enum type.\n");
    output.push_str("    ///\n");
    output.push_str("    /// Returns `None` if the string doesn't match any known value.\n");
    output.push_str("    pub fn from_str(s: &str) -> Option<Self> {\n");
    output.push_str("        match s {\n");
    for value in values {
        let variant_name = to_pascal_case(&value.name);
        output.push_str(&format!(
            "            \"{}\" => Some(Self::{}),\n",
            value.name, variant_name
        ));
    }
    output.push_str("            _ => None,\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // iter() method
    output.push_str("    /// Returns an iterator over all values of this enum.\n");
    output.push_str(&format!(
        "    pub fn iter() -> impl Iterator<Item = {}> {{\n",
        enum_name
    ));
    output.push_str("        [\n");
    for value in values {
        let variant_name = to_pascal_case(&value.name);
        output.push_str(&format!("            Self::{},\n", variant_name));
    }
    output.push_str("        ].into_iter()\n");
    output.push_str("    }\n\n");

    // count() method
    output.push_str("    /// Returns the total number of values in this enum.\n");
    output.push_str("    pub const fn count() -> usize {\n");
    output.push_str(&format!("        {}\n", values.len()));
    output.push_str("    }\n");

    output.push_str("}\n\n");

    // Display impl
    output.push_str(&format!("impl std::fmt::Display for {} {{\n", enum_name));
    output.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    output.push_str("        f.write_str(self.as_str())\n");
    output.push_str("    }\n");
    output.push_str("}\n\n");

    // Default impl - use first value
    if !values.is_empty() {
        let first_variant = to_pascal_case(&values[0].name);
        output.push_str(&format!("impl Default for {} {{\n", enum_name));
        output.push_str("    fn default() -> Self {\n");
        output.push_str(&format!("        Self::{}\n", first_variant));
        output.push_str("    }\n");
        output.push_str("}\n");
    }

    output
}

/// Convert a string to PascalCase.
///
/// Handles common patterns like:
/// - "in" -> "In"
/// - "out" -> "Out"
/// - "inout" -> "Inout"
/// - "public" -> "Public"
/// - "do" -> "Do_" (reserved keyword)
fn to_pascal_case(s: &str) -> String {
    if s.is_empty() {
        return String::new();
    }

    // Handle special case for reserved Rust keywords - return early
    match s {
        "do" => return "Do_".to_string(), // "do" is a reserved keyword
        _ => {}
    }

    let mut result = String::new();
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' || c == ' ' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ttl_parser::EnumValue;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("in"), "In");
        assert_eq!(to_pascal_case("out"), "Out");
        assert_eq!(to_pascal_case("inout"), "Inout");
        assert_eq!(to_pascal_case("public"), "Public");
        assert_eq!(to_pascal_case("snapshot"), "Snapshot");
        assert_eq!(to_pascal_case("do"), "Do_"); // Reserved keyword
    }

    #[test]
    fn test_generate_single_enum() {
        let enum_info = EnumInfo {
            name: "FeatureDirectionKind".to_string(),
            values: vec![
                EnumValue {
                    name: "in".to_string(),
                    comment: Some("Input direction.".to_string()),
                },
                EnumValue {
                    name: "out".to_string(),
                    comment: Some("Output direction.".to_string()),
                },
                EnumValue {
                    name: "inout".to_string(),
                    comment: None,
                },
            ],
            comment: Some("Direction of a feature.".to_string()),
        };

        let code = generate_single_enum(&enum_info);

        // Check enum definition
        assert!(code.contains("pub enum FeatureDirectionKind"));
        assert!(code.contains("In,"));
        assert!(code.contains("Out,"));
        assert!(code.contains("Inout,"));

        // Check methods
        assert!(code.contains("pub const fn as_str(&self)"));
        assert!(code.contains("Self::In => \"in\""));
        assert!(code.contains("Self::Out => \"out\""));

        assert!(code.contains("pub fn from_str(s: &str)"));
        assert!(code.contains("\"in\" => Some(Self::In)"));

        assert!(code.contains("pub fn iter()"));
        assert!(code.contains("pub const fn count()"));
        assert!(code.contains("3")); // count

        // Check Display impl
        assert!(code.contains("impl std::fmt::Display for FeatureDirectionKind"));

        // Check Default impl
        assert!(code.contains("impl Default for FeatureDirectionKind"));
    }

    #[test]
    fn test_generate_value_enums() {
        let enums = vec![
            EnumInfo {
                name: "FeatureDirectionKind".to_string(),
                values: vec![
                    EnumValue { name: "in".to_string(), comment: None },
                    EnumValue { name: "out".to_string(), comment: None },
                ],
                comment: None,
            },
            EnumInfo {
                name: "VisibilityKind".to_string(),
                values: vec![
                    EnumValue { name: "public".to_string(), comment: None },
                    EnumValue { name: "private".to_string(), comment: None },
                ],
                comment: None,
            },
        ];

        let code = generate_value_enums(&enums);

        // Should contain both enums
        assert!(code.contains("pub enum FeatureDirectionKind"));
        assert!(code.contains("pub enum VisibilityKind"));
        assert!(code.contains("Generated 2 value enumeration types"));
    }

    #[test]
    fn test_handles_empty_enum() {
        let enum_info = EnumInfo {
            name: "EmptyKind".to_string(),
            values: vec![],
            comment: None,
        };

        let code = generate_single_enum(&enum_info);

        // Should produce empty output for enums with no values
        assert!(code.is_empty());
    }

    #[test]
    fn test_handles_reserved_keyword_do() {
        let enum_info = EnumInfo {
            name: "StateSubactionKind".to_string(),
            values: vec![
                EnumValue { name: "entry".to_string(), comment: None },
                EnumValue { name: "do".to_string(), comment: None },
                EnumValue { name: "exit".to_string(), comment: None },
            ],
            comment: None,
        };

        let code = generate_single_enum(&enum_info);

        // "do" should become "Do_" to avoid keyword conflict
        assert!(code.contains("Do_,"));
        assert!(code.contains("Self::Do_ => \"do\""));
        assert!(code.contains("\"do\" => Some(Self::Do_)"));
    }
}
