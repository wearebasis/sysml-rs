SysML v2 Visualization Review and Recommendations
Alignment with SysML v2 Notation Conventions

Definition vs. Usage Notation: A fundamental SysML v2 convention is to visually distinguish definition elements from usage (instance) elements. In SysML v2, definition elements (e.g. Part Definitions) should be rendered as rectangles with sharp corners, whereas usages (e.g. Part usages/instances) are shown with rounded corners. Currently, your diagrams do not clearly enforce this distinction – for example, a Block (Part Definition) and its Part usage appear with the same shape. Adopting this convention will make your diagrams immediately clearer. For instance, in a General view diagram, a block definition “Vehicle” would have sharp corners, while a part usage “vehicle1” (of type Vehicle) would use rounded corners to indicate it’s an instance in context

. Implementing this shape difference for all element types (blocks, requirements, use cases, etc.) that have definition/usage variants will bring the visuals in line with SysML v2 style.

Naming Conventions: SysML v2 prescribes specific naming guidelines that can reflect in the visuals. Notably, definition names typically start with an UpperCase letter, while usage (instance) names start with lowerCase. CamelCase is recommended and spaces should be avoided. In your model, it would improve clarity to follow these conventions: e.g., a Part Definition might be named EngineController (upper camel case), while its usage inside a system could be controller1 (lower camel). This convention, combined with the shape differences above, helps readers instantly recognize definitions vs usages. It might also be useful to update the textual labels in the diagram to reflect SysML v2 terminology – for example, use “Part Definition” instead of “Block” for structural definitions, and “Part” (or simply the instance name) for usages. Likewise, if your diagrams still use older terms like “Block” or “Connector,” consider using the SysML v2 terms “Part Definition” and “Connection” respectively

. Adopting the updated vocabulary in element labels and legends will underscore compliance with SysML v2 standards.

Diagram Frames and Titles: Each SysML diagram should be drawn with a diagram frame that includes a header identifying the view type and context element. In SysML v1, the frame header would show the diagram kind (e.g. bdd, ibd, etc.), the context element type/name, and an optional diagram name. SysML v2’s concept of Views is analogous – for example, a General View might be labeled with a prefix “[GV]” or simply “General View:” followed by the name of the model element it depicts. Currently, some of your test output images have what looks like a frame (e.g. a bounding box for the diagram, sometimes with a small corner marker). However, the labeling can be improved. Ensure the frame header text clearly states the view type and the context. For example: “General View – VehicleSystem” at the top of a general structure diagram, or “Interconnection View – VehicleSystem” for an internal structure diagram of VehicleSystem. This aligns with SysML practice of making the diagram’s scope obvious in the header

. In cases where a diagram corresponds to a specific SysML v2 View Definition (perhaps you have elements like SafetyView in your model), you might also include the view name there. The key is to consistently annotate the diagrams so that readers know what kind of view they are looking at and which model element or aspect it represents.

Stereotype and Metadata Notation: You already label elements with their kind (e.g. “PART PartDefinition” or “REQ RequirementDefinition”). This is helpful, but consider simplifying the presentation once the audience is aware of shape and naming cues. In many SysML diagrams, the stereotype or element type may be shown in guillemets or as a keyword (e.g., «requirement» in a requirement box) rather than a long “REQ RequirementDefinition” label. For example, a requirement could simply show «Requirement» above its name, and a part usage might not need any label if the shape (rounded) and naming (lowercase) already indicate it’s a part. That said, including these labels for learning or clarity is fine. Just ensure they use correct SysML v2 terminology (like PartDefinition, PartUsage, RequirementDefinition, etc.) and perhaps a shorter notation (using the «» notation or a prefix like << >>) to reduce visual clutter. For instance, instead of STAKE StakeholderDefinition, you might use «stakeholder» above the name. This aligns with typical SysML notation where stereotypes are shown in guillemets and in a concise form.

Ports and Interfaces: It’s great that your meta-model includes things like FullPort and FlowPort. However, SysML v2 has streamlined ports by removing the old distinction of “Flow Ports” vs “Full Ports” from SysML v1 – every Port in SysML v2 is essentially a typed interface/connector point, analogous to proxy ports in v1. In practice, all ports should be defined with an interface or item type, and untyped/“plain” ports are discouraged. Make sure your visual conventions for ports reflect this unified approach. For example, you might use a single small square symbol on block borders for all ports, perhaps with a color or icon indication if it’s an input/output interface. In your current diagrams, ports were not visibly rendered on the block shapes (for instance, in the Interconnection view we see connections drawn, but not the port symbols on the part shapes). Include port symbols on the edges of part rectangles and connect the lines to those ports. A green or blue filled square (as hinted by your code styling) is a good start – e.g., you could use green squares for full/interface ports and blue for flow-specific connectors, if you want to distinguish provided vs. consumed interfaces. By explicitly drawing ports, it becomes clearer where connections attach, improving the diagram’s precision. Additionally, when a connection between parts represents a specific interface, consider labeling it with the item or interface that flows through it (since SysML v2 allows specifying item flows as part of the connection definition). For example, a red arrow connection could have a <<flow>> stereotype or a small icon denoting the flow content. Ensuring ports and interfaces are visualized will align your diagrams with the SysML v2 emphasis on explicit interfaces and connections, and it will leverage the fact that SysML v2 integrates item flows into connections directly

(meaning the diagram can show what is flowing on a connector without a separate adornment).

Relationship Notation (Arrows & Diamonds): Use standard UML/SysML iconography for relationships so that the intent is recognizable. For instance, generalization/specialization should be shown with a solid line and an unfilled triangle arrowhead pointing to the more general element (parent) – you might not even need to label it “Specialization” on the diagram, as the triangle arrow conveys that meaning. If you do label it, “«specializes»” could be used near the arrow. Your General view output showed a line labeled "Specialization" between elements; converting that to the conventional triangle arrow (with or without a «specializes» label) will be more in line with SysML/ UML visuals. Similarly, composition vs. aggregation vs. association can use the standard diamond notation: a filled black diamond at the aggregate end for composition, an open diamond for shared aggregation, and no diamond (or just a plain line) for simple associations. In a Block Definition or General view diagram, if you show part-whole relationships, adding a black diamond on the owning end will clearly indicate a composition (containment) relationship

. Ensure that these markers are used consistently. For example, if Vehicle contains Engine (as a part), a line from Vehicle to Engine should start at Vehicle with a filled diamond. If it’s just a reference association, no diamond should be present. Also, for dependency or other relationships (like «satisfy», «deriveReqt», etc.), use the standard dashed line with an open arrow where appropriate. It looks like you have satisfy and verify relationships drawn (red and purple lines in the General view). That’s good – just ensure the arrow direction is correct (e.g., a «satisfy» relationship is usually drawn from the model element (e.g., a part or behavior) to the requirement that it satisfies). Keep the textual labels like «satisfy», «verify», «derive» near those lines so the type of relationship is evident. These conventions will make the diagrams immediately more readable to those familiar with SysML.
Diagram-Specific Layout and Clarity Improvements

Each standard SysML v2 view has its own best practices for layout. Below, we address each diagram type in your tool, noting observed issues from the test outputs and recommending improvements:
General View (Structure Definition Overview)

The General View is analogous to a SysML 1.x BDD, but SysML v2 allows it to include both definition and usage elements together for an integrated overview

. In your GeneralView output (the overview diagram with packages, requirements, blocks, views, etc.), all relevant model elements are shown – which is great, but the layout can be optimized for clarity. Right now, the diagram appears quite busy: we have Packages (e.g. VehicleProject, Definitions, Requirements), Part Definitions (e.g. Vehicle, Engine), a Part usage (vehicle1), Requirement Definitions (SafetyReq, PerfReq), and even viewpoint/stakeholder elements all in one view.

To improve this:

    Group by Category: Consider arranging elements in clusters by their category or concern. For example, all Packages could be grouped together (e.g. at the top or in one corner), all Requirement Definitions in another area, and all Part Definitions in another. In your diagram, the packages were at the top (VehicleProject, etc.), which is fine. The requirements (SafetyReq, PerfReq) were to the right in pink, and part definitions (Vehicle, Engine) more to the left. This general grouping by type is good – you should reinforce it by spacing. Increase the separation between these groups so that the relationship lines (derive, satisfy, etc.) are easier to trace without overlapping other nodes. For instance, keep requirement nodes together and perhaps align them vertically, while placing the block definition nodes together, aligned vertically or horizontally. This way, a satisfy link from a block to a requirement will clearly cross the space between those two groups and not tangle with unrelated elements.

    Reduce Line Crossings: Try to route relationship lines so they do not all run through the center of the diagram. If necessary, use slight curvature or orthogonal (right-angle) segments for some connectors to avoid overlaps. In the current GeneralView image, relationships like «satisfy» and «verify» from Engine to SafetyReq overlapped each other and other elements. You might offset parallel relationships – for example, if Engine both satisfies and verifies SafetyReq, those two lines can be drawn with a small separation (one arcing above the other) so both arrowheads and labels are visible and not directly on top of each other. It looks like you attempted a slight curve for one, which is good; ensure the text labels (“Satisfy”, “Verify”) are placed next to their respective line in a way that they don’t collide.

    Clarify “Type vs Instance” Links: The link between vehicle1 (Part usage) and Vehicle (Part definition) was labeled "TypeOf" in the image. Rather than explicitly labeling this, you might convey the same information by notation. In SysML diagrams, a part usage is usually shown as an attribute-like label in a compartment (e.g. vehicle1: Vehicle) or as a separate shape connected by a composition link (black diamond) from the container. Since SysML v2 general view can show parts alongside definitions, one approach: draw vehicle1 as a separate shape (rounded corners, since it’s a usage) and connect it to its defining block Vehicle with a dashed line or a special symbol. However, the more standard notation (if vehicle1 is meant to be a part inside some container) would be to show it inside an Internal/Interconnection view rather than the general view. If you’re including it in the general view for completeness, perhaps label the line as «instanceOf» or simply omit the line and rely on naming (vehicle1: Vehicle). Since SysML v2 general views are flexible

    , it’s not “wrong” to have it, but ensure this doesn’t confuse the reader. A possible improvement: Put vehicle1 inside a compartment of its owning context (if the context is VehicleProject or a higher-level block), instead of floating as an independent node. If vehicle1 is meant to represent a system instance, you could alternatively show it in an Interconnection View of its parent (see below). In summary, keep the General view focused on definition-level relationships (specializations, associations, requirement traceability, package structure, etc.), and use the Interconnection view to show part usages in context.

    Package Relationships: The General view diagram shows packages (like VehicleProject containing Definitions and Requirements packages) with lines labeled "Contains" or "Import". This is good to illustrate model structure. To follow convention, package containment can be shown either by nesting the package symbols (i.e., drawing Definitions package inside the border of VehicleProject package symbol), or by a containment relationship line with a small open arrowhead or just a hierarchical tree. If using lines, a common UML convention is a dashed line with an open arrow to show package import. You labeled "Import" between some packages – ensure that specifically reflects a package import (if so, the arrow should point from the importing package to the imported package, and "«import»" could be the label). For containment (ownership), a simple line with a filled diamond at the owner (similar to composition) is sometimes used, or you can rely on the frame to imply containment. Since VehicleProject is the root, it’s acceptable to simply position Definitions and Requirements beneath it with a note that they are contained. The key is to avoid clutter: if those “Contains” lines are making the diagram messy, you might drop explicit "contains" labels and just use a nesting visual (like overlapping shapes or a hierarchical tree view separately). Alternatively, show a Browser View (hierarchy) for the package breakdown (which you have as a separate diagram) and keep the General view focused on cross-cutting relationships.

    Colors and Legends: You’ve used color to differentiate element types (e.g., packages in green, requirements in pink, views in blue, etc.). This is a helpful visual cue. Include a small legend or consistent styling so that readers know, for instance, pink rounded box = Requirement, white rectangle = Part Definition, blue = View/Viewpoint, etc. Over time, the shape and text cues should suffice, but color adds quick recognition. Just ensure the colors are not too harsh and that text is readable (your pastel tones looked fine). If possible, keep a consistent palette across diagrams (the same pink for requirements in both the General view and Grid view, for example). Consistency will reinforce the convention (e.g., readers see pink and know “that’s a requirement element”).

Interconnection View (Internal Block Structure)

The Interconnection View corresponds to an internal structure diagram (like SysML v1’s IBD) and should emphasize how parts are connected and how interfaces flow

. In your InterconnectionView output for the VehicleSystem, the approach taken was to draw a big frame for VehicleSystem and list its parts (sensor1, controller1, bus1, power1) as text, with connectors drawn inside. While this is a valid way to represent internal structure information, it can be improved to match typical SysML diagram conventions:

    Depict Parts as Separate Nodes: Instead of only listing parts in a text compartment of the frame, try rendering each part as a distinct sub-block inside the context. In a standard SysML IBD, one would draw the containing block’s frame (VehicleSystem) and then place smaller rectangles inside it labeled sensor1: Sensor, controller1: Controller, etc., to represent each part property. These part boxes can be free-floating inside the frame (and you can position them logically, e.g., sensor on left, controller in middle, etc., depending on the system’s structure). Each part box can still be drawn with rounded corners (since they are usages) and possibly a lighter border since they are contained elements. You can optionally keep the list format in addition (compartment listing parts), but visually seeing separate boxes will make the connectors much clearer.

    Show Ports on Parts: As mentioned earlier, include port symbols on these part boxes where appropriate. For example, if sensor1: Sensor has a port for sending data, draw a small square on the side of the sensor1 box. Likewise, if controller1 has a port for receiving that data, a corresponding port on that box. In the diagram image, we saw red lines labeled “sensorData [1]” and “power” floating; presumably these represent connections carrying certain items (data and power). If ports were drawn, those red connector lines would start at one part’s port and end at another part’s port, making it obvious which part connects to which. The label (e.g., “sensorData”) could be placed alongside the line or near the port. This follows SysML practice: e.g., in an IBD, a connector line often runs between ports or between part boundaries, and is sometimes labeled with the item flowing. By doing this, you leverage SysML v2’s emphasis that interconnection views explicitly show connections and interfaces between parts

.

Avoid Ambiguous Routing: In the current Interconnection diagram, the red “power” line appears to loop around multiple components (likely indicating a common power bus connecting several parts). If multiple parts share a connection, consider drawing a small node or hub to clearly join them (for example, a dot or a junction where three lines meet). Alternatively, draw separate connector lines from the power source to each consumer to avoid one single line bending around. A clearer approach: show a part power1: PowerSupply and give it an output port “powerOut”, and give each consuming part (sensor, controller) an input port “powerIn”. Then draw a connector from power1’s port to sensor1’s port (label it if needed) and another from power1’s port to controller1’s port. This way, it’s obvious that both sensor and controller receive power from the same source, without a single line zig-zagging. Each connector could carry a label or just rely on the port names (if the port is named “powerIn”, a label might be redundant). The main goal is to simplify connector geometry: use straight or orthogonal lines and avoid having one connector attach to more than two elements in a single stroke (multi-end connectors are allowed, but they often confuse drawings – splitting them into multiple lines or a star junction is easier to read).

Frame Label and Context: The frame of an interconnection diagram should identify the context part definition whose internals are shown. It looks like your frame was labeled with PKG <<part def>> VehicleSystem (perhaps a mislabel). It should probably be just the block name (VehicleSystem) and its type. In SysML v1, an IBD frame would be labeled like ibd [Block] VehicleSystem in the header. For SysML v2, you could say “Interconnection View – VehicleSystem” as the title. Also, ensure that VehicleSystem’s own interface to the outside is represented if needed. In IBDs, we often place relevant external ports on the frame boundary (the context frame) to show how this system connects outward. For example, if VehicleSystem as a whole has a port (say an interface to an external power grid or a data link out), that could be drawn on the border of the big frame. In your test, maybe VehicleSystem’s external ports weren’t a focus, but keep this in mind if needed.

Composition vs Reference for Parts: Since parts are by definition contained in their owning block, you could optionally use the composition notation to reinforce that (e.g., a black diamond on the VehicleSystem side where a connector line attaches to VehicleSystem’s frame, indicating that sensor1, controller1, etc. are internal parts). However, if you draw the parts inside the frame, it's already clear they are internal, so an additional composition symbol might be redundant. Another approach: list the parts in a compartment labeled “parts” within the frame (which you did as text), and draw them as shapes – though this duplicates information. Many tools simply draw the shapes and omit the text list. You can choose either style, but ensure consistency. The SysML v2 guidance mentions containment can be shown by nesting or compartments

    – find a balance that doesn’t clutter the diagram. Perhaps use the textual compartment if the diagram is too crowded to show all part shapes; otherwise, shapes are preferable for showing connections.

    Routing of Connections: Use orthogonal (right-angle) connector routing inside the frame if it helps avoid overlaps. For example, a data connection from sensor1 (left) to controller1 (right) could go out of sensor1’s right port, then straight right to controller1’s left port – a simple horizontal line. If a connector must go around a part, consider routing it up or down along the frame then over. The current curved lines can be replaced with cleaner straight segments since the relative positions of parts will be under your control with the new layout. Tools or libraries that auto-route orthogonal connectors can help here.

In summary, make the interconnection view look like a schematic of the system: each part clearly drawn, ports explicitly shown, and connections as neat lines between ports. The interconnection view should give a granular visualization of interfaces and connectivity

, which will be achieved by the above improvements.
Action Flow View (Activity Diagram)

Your ActionFlowView (activity diagram) already contains many elements of a well-structured activity: you have swimlanes (partitions) for roles (e.g. Engineer vs System lanes), actions with pins, decision nodes, and control flows. This is a complex diagram, and you’ve done well representing concurrent flows and events. To refine it:

    Swimlane Layout: The partition lanes (Engineer, System) are clearly separated by vertical dashed lines and labeled at the top – this is good. One improvement is to ensure that the lane labels include the element type if appropriate. For instance, if Engineer is an actor or a role, you could label it like «partition» Engineer or with the element it represents (e.g., if Engineer is an actor, maybe use the stick-man icon or stereotype). Same for System – is that a subsystem or just indicating system-side actions? If it corresponds to a block or part, clarify it (perhaps “System: VehicleSystem” if these actions are inside the system’s behavior). Keep the lane labels short and clear, and maybe style them differently (some diagrams gray the background of the header). Minor stylistic tweak: you could center the partition names and use a slightly larger or bold font to distinguish from action names.

    Action Notation: Currently each action appears as a rounded rectangle labeled with the action name and “ActionUsage”. As noted earlier, the stereotype “ActionUsage” might not be necessary on every node visually. In SysML (and UML), an action is typically just named by its verb phrase (e.g., Capture Sensor Data). If you want to distinguish between action definitions and usages, you could perhaps do that in a separate way, but usually, we just depict the flow of actions without that label. Since SysML v2 formally distinguishes action definition vs usage, it’s fine in the model, but diagram-wise you might simplify. Consider removing “ActionUsage” from the node labels for brevity, unless the context demands it. The icon or shape already implies it’s an action. Also, if any of these are special kinds of actions (like Accept Event or Send Signal actions), using the corresponding icon would be ideal. For example, an Accept Event Action in UML/SysML is often drawn as a concave-edged rectangle (a rectangle missing a small notch on one side) with a little receiving signal icon, and a Send Signal Action is drawn with a similar shape and an outgoing arrow icon. In your diagram, I noticed actions labeled like “Notify Operator” and “Receive Ack” with stereotypes «send» and «accept» (and maybe an hourglass symbol for a time event). It appears you attempted to indicate these, possibly with dashed borders. If possible, use the standard symbols: e.g., for a time event (timeout), you can use a small clock icon or note «time» explicitly next to the accept time event action. For the send action, a small filled arrow icon could be drawn inside the shape. If implementing custom icons is too involved, a simpler solution is to use text stereotypes like «send» and «accept» as you did, but ensure they are placed above the action name (standard UML style: «send» Notify Operator). This makes it clear those actions are not normal actions but sending/receiving events.

    Control Flows and Object Flows: The arrows connecting actions (control flows) should have consistent styling. It looks like you used solid brown arrows for control flow, and possibly the same for object flows. Distinguish them if needed: e.g., you could use a solid line with filled arrow for control flow, and a dashed or open-arrow for object flows (or simply label object flows with the object names, which you did via pins). The diagram shows little pin shapes like sensorPayload, capturedData, auditRecord, which is excellent – they serve as object inputs/outputs. Ensure those pins are aligned on the sides of actions (input pins on the left, output pins on the right of an action symbol) so it’s visually intuitive. For example, sensorPayload coming into “Capture Sensor” on the left, and capturedData leaving on the right, etc., as I believe you have. If any pins appear oddly placed, adjust them to avoid overlap (the snippet looked fine in this regard).

    Decision and Merge Nodes: You have a decision diamond labeled “Intent?” with outgoing guards like [yes]/[no]. This is correct usage of a decision node. Just make sure guard expressions are in brackets and placed on the appropriate outgoing arrow (it appears you did that). Also, any incoming arrow to a decision should have no guard. If you have a merge node (similar diamond where flows rejoin), handle guard labels similarly (though merges don’t typically have guards). If you intended the diamond after “Error” to be a merge or junction, ensure the notation is clear (a filled small circle is typically a junction pseudostate in state machines, but in activities, a diamond is used for both decision and merge – distinguished by context).

    Forks and Joins: I see a horizontal or vertical thick bar (fork/join node) after the “Capture Sensor” action labeled “ready” in your diagram. Fork/join nodes should be drawn as solid bars (horizontal for splitting into parallel flows, vertical for joining parallel flows, depending on orientation of the flow). It looks like you drew a horizontal bar for the “ready” signal to initiate parallel routes, which is correct if after that point the flow splits (perhaps into routing payload and logging event in parallel). If multiple flows converge into one, you’d use a bar again for the join. Make sure these bars are perfectly straight (not tilted) and wide enough to connect all incoming/outgoing arrows cleanly. Also, labeling a fork/join is unusual (they don’t get a name), but you might have just placed the “ready” text near it to indicate a control token. If “ready” is meant to be a boolean control or a condition, maybe it was intended as a guard or just an annotation. Typically, control flows can have guard conditions too. If “ready” is a guard, it should be in brackets on the outgoing flows (e.g., [ready]). If it’s an event name, it might belong to a signal or similar. Double-check what that text is meant to convey and format it accordingly (guard, signal, etc.). If not needed, removing stray labels can reduce confusion.

    Layout and Spacing: The activity is already quite dense. Try to utilize more canvas space to spread out nodes. For example, the “Build Structure” and “Simulate Behavior” actions (after the “Intent?” decision) could be placed with some horizontal gap between them if they execute in parallel, and then perhaps both flow into a subsequent node. If those two parallel actions later synchronize, draw a join node after them. Ensure the flow from “Simulate Behavior” to “Notify Operator” (with maybe a label “bloopor”? That label was unclear) is drawn clearly – I suspect “bloopor” might be a placeholder or some data object name. If it’s not intended, remove or rename it to something meaningful. If it is meaningful, clarify it (could it be a signal name or a typo of something like “bluetooth” or “loopback”?). Such odd text can confuse readers, so cleaning up labels is important.

    Exception/Timeout Handling: The lower-right of the activity shows “Notify Operator” and “Receive Ack” presumably for sending a status and awaiting acknowledgment, and an “after 5s” timeout leading to an “on timeout” path. This is a complex scenario to show. To make it understandable: an Accept Time Event “after 5s” can be modeled as a small hourglass icon with [5s] next to it feeding into a flow that goes to an action or end. If you can, use the standard notation (hourglass or clock icon) for time events. You might depict it as an accept action labeled «accept time event» with “after 5s” inside it. It seems you tried to indicate it with text, which is okay. Just ensure the “on timeout” is labeled either on a transition or as an event. Possibly better: have a decision or merge that waits for either the ack or the timeout. Some modelers draw this logic using two accept actions in parallel – one for Ack, one for Timeout – and whichever comes first proceeds. If modeling that precisely is too involved, at least label clearly: e.g., [timeout] on the flow that goes from the time event to whatever happens (maybe raising an alarm or ending the activity).

    Final Nodes: I didn’t explicitly see an explicit final node in the activity snippet (maybe it’s off-screen). Be sure to end flows with a black activity final (encircled black dot) or flow finals as appropriate. If “on timeout” or receiving ack both terminate the process, they might both lead to a final node. Put that final node clearly at the end of the flow.

Overall, your action flow diagram is quite rich. The main improvements are clarifying the special actions, aligning the elements, and decluttering labels. The use of partitions, decision, and parallel bars is on the right track. With tidier spacing and proper UML/SysML iconography for accept/send actions and time events, this diagram will closely follow SysML norms.
State Transition View (State Machine Diagram)

The State Transition view should show states and transitions of a state machine clearly

. Your StateTransitionView output has the basic ingredients: states (Idle, Active, Running, Error, Recover, etc.), an initial state (black dot), a final state (bullseye), transitions with event names and guard conditions, and internal behaviors (entry/exit actions). Here’s how to refine it:

    State Containment: If Active is a composite state that contains substates Running and Error, it should visually encompass those substates. In the image, Active was drawn as a large state with entry/do/exit, but Running and Error appeared slightly outside or overlapping it (it was a bit unclear). Ensure that if Running and Error are substates of Active, they are drawn inside the boundary of Active’s state shape. You may need to draw Active as a large rectangle with rounded corners and then draw a region inside it where Running and Error sit. Often, a composite state’s internal activities (entry/do/exit) are listed at the top of the state, and a line separates them from the region where substates lie. Consider splitting the Active state box: the name and internal actions at the top, and below that a contained region where Running and Error are shown as nested states (with perhaps a border around them). If Active is not meant to contain them (i.e., if Running and Error are actually sibling states at the top level), then Active should not encompass them at all. It might be that Active, Running, Error are all top-level states and Active just had internal actions. If that’s the case, keep them separate and maybe don’t draw Running/Error inside Active. Clarity on the hierarchy is crucial. Double-check the model: if Active has substates, draw nesting; if not, ensure no accidental overlap that confuses the viewer.

    Transition Label Placement: The transition arrows have labels like event names, guard conditions in brackets, and possibly effect actions after a “/”. Make sure to format these as per convention: EventName [Guard] / EffectBehavior along the transition line. For example, you might have init / (if “init” is an event with no guard or effect) on the Idle→Active arrow. Or faultOccurred [critical] / raiseAlarm on a transition from Running to Error, etc. In your diagram, I saw “/ init()” near Idle – possibly the entry to Idle? If that was meant to be the trigger event for the initial transition, it should ideally be placed next to the arrow from the black initial dot to Idle: e.g., label that arrow “init”. If it was an entry action (“/init()” as entry behavior to Idle), it should be written inside Idle’s state box as entry / init(). So, verify each text on the diagram if it’s a trigger, guard, or internal action, and put it in the right place. Guards in brackets go on transitions, entry/exit actions go inside state boxes prefixed with entry/ or exit/. From the snippet, “entry/ activate()” and such were inside Active, which is correct. Just the "/ init()" was ambiguous – likely that was the transition from initial state to Idle triggered by an init event. Place it accordingly on that arrow.

    Initial and Final States: The initial pseudostate (solid black circle) should have one outgoing arrow to the default starting state (Idle). That arrow typically is unlabeled unless there is a special action that happens on initialization. If “init” is meant to be the event that kicks it off, you can label that arrow with «init». The final state (bullseye) should have incoming transitions from states that go to final. In your diagram, it looked like Recover had a transition labeled “complete” going into the final state symbol – that’s fine. Just ensure no transitions out of final (final state is a sink). The diagram shows final at bottom left and a line possibly going from Recover to final. That’s correct if “complete” triggers the end. If you also have a transition from Error going back to Idle (maybe after recover), place it so it doesn’t conflict with the final state’s arrow. Use curved or dogleg lines to avoid crossing the state shapes.

    Transition Routing: Avoid routing transition lines over state boxes if possible. It seemed a transition from Error to Recover might have overlapped the Active state shape. You can route such lines around the outside of other states or loop them a bit. Often, a good layout is to put the initial state at the top left, final at bottom right, and arrange other states in between such that most transitions flow left-to-right or top-to-bottom (if there’s a logical sequence). If a transition is a self-loop or goes backwards, curve it around the state. For example, a self-loop on Running should be drawn as an arrow hooking back to Running itself (maybe a small loop arrow on the side of the state). Try to position guard/trigger text near their arrows without overlapping state boxes. If necessary, break a long transition into two segments with a jagged elbow to place a label clearly.

    State Stereotypes: Similar to actions, you labeled each state with “StateUsage”. In SysML and UML diagrams, we typically do not label states with their type; we just use the name. If you want to indicate something special (like a composite state vs simple state), you might use a different visual (composite states have regions). I would recommend removing “StateUsage” from the state labels to reduce clutter, unless you also plan to show some state definitions (which I doubt, since usually we just show the usage in the context of the state machine). The rounded rectangle shape inherently implies a state. If you have any special state like a choice pseudo-state (the diamond) or junction (small filled circle) or terminate, ensure you use the correct symbol. From what I saw, you used a diamond for a decision/choice (which is correct) in an activity diagram context, but in state machines, a similar diamond can be used for junctions. If that diamond in your state diagram is meant to be a junction (merging transitions), it should be a small filled black circle if it’s a junction, or a hollow circle if it’s a choice. This is a subtle point: UML statecharts have “choice” (like a dynamic decision) depicted as a diamond and “junction” (static merge point) depicted as a small filled circle. If you intended a guard-based branch after Error (like [yes]/[no]), using the diamond is acceptable to denote a choice pseudo-state. Just be sure the notation is clear (maybe add a tiny “J” or something if junction, but not necessary). The presence of “[yes]” and “[no]” makes me think it’s a choice, so diamond is fine.

    Colors and Formatting: If you color-coded states (they all looked similar color in the snippet), that’s fine. Some modelers use different colors for different state regions or to highlight initial vs final, but that’s optional. One thing you could do: make the initial and final nodes slightly larger or more pronounced so they’re visible (the final state’s double circle should be clearly drawn). Also, if you have an internal transition (like something that happens on an event but doesn’t change state), you could list it inside the state or as a note. It wasn’t shown, so maybe none in this example.

In summary, for the state machine diagram: keep the hierarchy clear, transitions clearly labeled, and layout in a logical flow. State machines can get messy quickly, so a clean arrangement (perhaps grid-like positioning of states) and consistent notation will help. This view should cleanly illustrate how the system moves between states on events

.
Sequence View (Interaction Diagram)

The Sequence view is meant to show interactions over time along lifelines

. Your SequenceView output is one that likely needs significant layout adjustment to meet expectations. As it stands, the diagram in the PNG had message arrows drawn mostly horizontally and it was a bit hard to identify lifelines (there were small circles and perhaps dashed vertical fragments). To align with standard sequence diagram practice:

    Lifelines as Vertical Columns: Represent each participant in the interaction as a lifeline, drawn as a vertical dashed line. At the top of each lifeline, put a lifeline header box with the participant’s name (and optionally type). For example, you might have lifelines for an Actor (like “User” or “UI”), a Controller, a Service, etc., depending on the scenario. The name format can be like user: Actor or just the role name. If the lifeline represents a specific part of the system, use instance name: e.g. gui: UI or :UI if unnamed. Based on your sequence content (it had messages like selectPage(), fetchModel(), render()), I suspect the participants could be something like: UI (the front-end), Controller (the system logic), and maybe Model or Database. Ensure these are identified. In the diagram, perhaps the leftmost lifeline was the UI (which calls selectPage on the controller), the middle lifeline the Controller (which fetches model data from the model, and later renders), and the rightmost the Model. If you had an actor initiating, maybe the actor was off to the left sending the first message. Clarify this by labeling the lifelines and positioning them left-to-right in order of interaction flow (often the initiator or actor on left).

    Time Axis Orientation: Conventionally, time progresses downward in a sequence diagram

. That means the first message occurs at the top, later messages lower down. Your diagram seems to list messages top-to-bottom (selectPage at top, then fetchModel, then modelReady, then render at bottom) – that’s correct temporally. The issue was they were drawn almost horizontally with minimal downward slope. You should arrange the lifelines vertically and draw message arrows left-to-right or right-to-left between them, at the appropriate vertical position corresponding to the sequence order. For example, the selectPage() call might go from the User lifeline to the Controller lifeline near the top of the diagram. Then a bit lower, the Controller lifeline calls fetchModel() on the Model lifeline, drawn as an arrow from Controller to Model. Then perhaps the Model returns something or sends modelReady back to the Controller – that would be a message from Model lifeline back to Controller lifeline, drawn below the fetch call. Finally, the Controller calls render() on the UI lifeline (or maybe sends data back), drawn further down. By spacing these events vertically, you make the chronological order explicit.

Activation Bars: To enhance clarity, you can show activation bars on lifelines. An activation (usually a thin rectangle on a lifeline) indicates that lifeline is active or processing during a call. For instance, when the Controller receives selectPage(), draw a thin vertical rectangle on the Controller’s lifeline line to show it’s executing that operation until it sends out the next message or returns. Similarly, the Controller’s activation might extend through its call to fetchModel, pause while waiting for modelReady, etc. Activation bars are optional, but they help in understanding call nesting and lifeline responsibility. Even a simple approach like showing a bar on the callee lifeline for the duration until it responds can be useful.

Message Arrow Styles: Use different line styles for synchronous calls vs returns or asynchronous signals. A common convention: solid line with a solid arrowhead for a call (synchronous message), and dashed line with an open arrowhead for a return message. For example, fetchModel(): Model might be a synchronous call where the return value “Model” comes back on a dashed line. If modelReady is meant to be an asynchronous notification (e.g., the model publishes an event), you could depict modelReady with a solid line and a stick or open arrow to denote an asynchronous signal (UML uses a half-arrowhead or a found message symbol). If that’s too granular, at least label the return value on a dashed return arrow if you show it. In your text, I saw fetchModel(): Model which suggests you intended to show the return of a Model object. Depict that by drawing a dashed line from the Model lifeline back to the Controller lifeline, with an open arrowhead, labeled “:Model” or similar.

Self-Calls and Found Messages: If any message originates from or goes to a pseudo-lifeline (like an off-page actor), there are notations (like a solid circle or a lost message endpoint). In your case, it seems all interactions were between known participants, so we can ignore that. But if “selectPage()” was initiated by an external actor (say a user clicking a UI), you might optionally show a stickman actor on the far left sending selectPage() to the UI lifeline. If you want to keep it simpler, you can treat the UI lifeline as the initiator and skip explicit actor.

Layout: The diagram should have lifelines in parallel columns with equal spacing. For example, three lifelines could each occupy a third of the width. Messages go horizontally between them. Currently, your output had messages as mostly horizontal lines with some small vertical dashed segments (perhaps attempting to indicate lifelines). Expand those dashed segments into full lifelines spanning from near the top to bottom of the diagram (or until they are destroyed, if any end early with an X). If an object is destroyed (probably not in this scenario), mark that with an X on its lifeline. Ensure message arrows are staggered vertically (no two different messages at exactly the same vertical position, since one happens after the other). A good practice is to leave some vertical gap between messages for clarity.

Example Sequence Alignment: Concretely, suppose the sequence is: UI calls Controller:selectPage(), Controller calls Model:fetchModel(), Model returns data, Controller sends data to UI:render(). You would do: Lifeline A (UI) on left, Lifeline B (Controller) in middle, Lifeline C (Model) on right. Draw arrow from A to B at top labeled selectPage(). Slightly below that, draw arrow from B to C labeled fetchModel(). Below that, draw a dashed arrow from C back to B labeled «return» Model (or just “:Model”). Then below that, draw arrow from B back to A labeled render() (assuming the controller updates the UI). If there’s a modelReady asynchronous message instead of a return, you might depict the Model lifeline sending modelReady to Controller lifeline as a separate asynchronous message (solid line, open arrow) rather than a typical function return. That could replace or supplement the return arrow. The text “next” I saw might be a guard or indicator of a loop; if it was intended as a guard (like [next] meaning if there are more pages), you might be trying to show a loop or an alt fragment. If you intended to show a loop or alt scenario, consider using frame notation: UML sequence diagrams allow “interaction frames” like alt, loop, etc., drawn as a boxed region with a label in the top left. For example, to show a loop of selecting next page, you could put those interactions inside a loop [hasNext] frame. This is advanced, but if needed, it’s the proper way to capture loops/conditions in sequence diagrams.

Reference to Lifelines: It’s worth noting that SysML v2 still expects sequence diagrams to have lifelines and messages (the concept hasn’t fundamentally changed from SysML 1.x). The SysML v2 viewer description confirms it presents events on lifelines in chronological order
. Also, general UML references note that lifelines represent the participating objects/parts and messages between them represent interactions

    . So, aligning with these principles is essential. Right now, the absence of clearly drawn lifelines in your diagram is the biggest deviation. By adding them and ordering messages top-down, your SequenceView will meet expectations and become much more readable.

    Aesthetics: Use arrowheads that are sufficiently large and clear. Label each message near the arrow it corresponds to (either above or above and slightly to the left of the arrow for left-to-right messages, or to the right for right-to-left messages). If one message’s label is long and overlaps another arrow, adjust positions or break into multi-line label. It might help to tilt labels a bit or use vertical placement if lines are short. Also, ensure consistency in text (e.g., if one uses parentheses like selectPage(), do so for all function-like messages).

Once you introduce proper lifelines and vertical spacing, the sequence diagram will convey the temporal aspect correctly. The interactions will be much easier to follow, as one can trace each lifeline downwards and see when it sends or receives messages.
Grid View (Tabular/Matrix View)

The Grid view is a new SysML v2 view type intended to generalize various matrix and tabular representations

. Your GridView output is essentially a matrix: you had model elements listed on the rows and columns, with cells indicating relationships or values (for example, requirements vs parts with “Satisfy”, “Verify”, “Allocate” markers, and an attributes vs parts section with numerical values). This is a very useful view for tracing relationships (like a requirements traceability matrix or an allocation matrix) and for comparing properties across elements. To improve the grid:

    Separate Concerns (if needed): It appears you combined a Requirement traceability matrix and a Property table into one grid. The top rows (SafetyReq, PerfReq, ThermalReq) were requirements and you marked which parts satisfy/verify/allocate them. The bottom rows (mass, temperature) were attributes with values for each part. While this combined view is interesting, it might overwhelm a reader. Consider splitting them into two grids for clarity: one Relationship Matrix focusing on requirements vs parts, and one Property Table for part values. SysML v2 allows specialized tabular views (they mention a “Data Value Tabular View” vs “Relationship Matrix View”

    ). You can mirror that: for example, a Requirement Satisfaction Matrix where rows = requirements, columns = parts, and cells show «satisfy», «verify», etc.; then a separate Parameter/Property table where rows = properties (mass, temp) and columns = parts with their values. If you prefer to keep one grid, consider grouping the rows and visually separating them (maybe a thicker line or extra spacing between the requirement rows and the attribute rows).

    Visual Gridlines: Add faint grid lines or boundaries to delineate cells. In the current image, the colored cell backgrounds (pink, yellow, blue for relationships; white for empty; and maybe a different shade for value cells) provide some structure, but it’s a bit hard to follow which cell aligns with which row/column without lines. Even a light gray border around each cell or each block of cells would help readability. At minimum, draw a solid line separating the row labels (first column) from the data cells, and the column headers (top row) from the matrix. Ideally, draw a full grid. This way, one can trace a cell by following the grid lines up to the column header and left to the row label.

    Row/Column Labels: Make sure the column headers and row stubs stand out. You already label columns with part names (Vehicle, Engine, Sensor) presumably with their stereotype (PartDefinition). Perhaps bold these or give them a distinct background. Similarly for the row labels: “SafetyReq”, “PerfReq”, etc., could be prefixed with their kind (RequirementDefinition) as you did, but you might shorten it to «requirement» or a requirement ID if available (some models have an ID like RQ-001). If the names are self-explanatory, just the name is fine, but ensure it’s clear these are requirements vs properties. One idea: you could italicize or color the property names (mass, temperature) differently to distinguish them from requirements in the row labels. Or group them under a sub-heading “Properties:” separate from “Requirements:”.

    Cell Notation: The relationship cells are marked with the text “Satisfy”, “Verify”, “Allocate” in different colors – this is good for a prototype. To align more with SysML convention, you might use checkmarks or symbols in cells to indicate relationships in a matrix. For example, some tools put a check or an “X” and then use a legend that color X = Satisfy, triangle = Verify, etc. Alternatively, you could put the relationship letter (S, V, A) or even an icon (a little trophy icon for satisfy, test icon for verify, arrows for allocate, if you wanted to get creative). But text is fine too. The main thing is to ensure multiple relationships in one cell are handled without clutter. In your grid, Engine vs PerfReq seemed to have both “Satisfy” (pink) and “Verify” (yellow) in the same cell. If a part both satisfies and verifies the same requirement (which is somewhat unusual, but maybe Engine “satisfies” a performance requirement and “verifies” it through simulation – possible), then in that single cell you should show both indicators. Right now they overlapped (pink text on yellow background perhaps). Instead, you could list them separated by a comma or line break: e.g., in Engine–PerfReq cell, have Satisfy; Verify (each maybe in its own small colored tag or text on separate lines). Make the cell large enough to contain both without overlap. If your rendering system struggles with stacking text, consider splitting that into two cells by duplicating either the row or column (not ideal) or use a multi-line text box in the cell.

    Numeric Values: The attribute values (e.g., 1200 kg for Vehicle mass, 220 kg for Engine mass, etc.) are nicely shown. Just make sure they align correctly under the right columns and next to the correct property. The snippet showed “1200kg” under Vehicle, “220kg” under Engine in the mass row – that looked correct. If possible, align numbers right within their cell, especially if they have units, so that the unit is consistently after the number and easier to scan. You might also format them (like “1,200 kg” with a comma if large, though not necessary). For temperature, include the degree symbol if you can (“95°C” rather than “95 C”, minor typography point).

    Legends and Keys: A small legend would help here: for example, you could add a note or a caption below the grid: Key: Pink = «satisfy», Yellow = «verify», Blue = «allocate». Or list the abbreviations if you go that route. This way, if someone prints the diagram in grayscale or is color-blind, they can still differentiate via text labels or positioning. Alternatively, incorporate the legend into the header: maybe each relationship type could be a column grouping – but since you put them in the cells, an external legend is simplest.

    Scalability: If this grid is generated from data, consider how it will scale with more requirements or more components. The layout should ideally allow dynamic growth. One suggestion is to rotate column headers vertically if names are long, to save horizontal space (for example, if you had “AutonomousControllerSubsystem” as a column, vertical text would keep column narrow). In your current case, names are short enough, so not an issue.

The Grid view is intended to be a structured, intuitive representation of model relationships

. By cleaning up the cell layout and separating different types of information, you’ll make it far more intuitive. Right now it’s already showing a lot of info – just refine the presentation as described. A crisp matrix with clear headings and segregated cells will be an excellent addition to the more graphical views, in line with SysML v2’s push for tabular views.
Browser View (Model Hierarchy)

The Browser view you generated provides a tree of the model hierarchy

, which is very useful for orientation. Your BrowserView output lists elements like VehicleProject, with sub-nodes Definitions, Requirements, Views, etc., and further sub-items like requirements and viewpoints. To ensure it matches expectations:

    Tree Structure Conventions: The way you showed plus + and minus – signs next to packages (e.g., + Definitions, – Requirements) is great – it mimics the look of a tree view in a tool, indicating collapsed vs expanded packages. Continue with that convention. Make sure the nesting is indicated either by indentation or connecting lines. I see you drew dotted connector lines from parent to child (like the typical tree structure lines). That’s good; maybe use solid lines or “L” shaped connectors to mimic a file-system tree. Dotted is okay too, just ensure they align perfectly to the list (each child node connected to its parent).

    Indentation and Alignment: Each level in the hierarchy should be indented to the right. It appears in your image that child nodes were indeed slightly offset. You might increase the indent for each level to make the hierarchy more obvious. For example, SafetyReq and EmissionsReq should be clearly under Requirements. If needed, add an extra 10-20 pixels indent for each depth level. Also, align siblings vertically with equal spacing.

    Icons for Element Types: In many browser views, little icons are shown next to each element (folder icon for packages, document icon for requirements, block icon for parts, etc.). You might consider adding small icons on the left of each item label. Since you already differentiate by text (PKG, REQ, CONCERN, VIEW, etc.), this is optional. But a visual icon can be quicker to parse. For example: a folder symbol for packages (VehicleProject, Definitions, etc.), a requirement document icon for requirements, a block cube icon for parts or definitions. If that’s too much graphical work, the text prefix (PKG/REQ/VIEW…) is fine. Perhaps just ensure the prefixes use consistent abbreviations (you used full words like “Package”, “RequirementDefinition”, etc.). Maybe shorten those: e.g., use «pkg» instead of “PKG Package” repetitively – you could list just the name with an icon or stereo. However, since this is a “browser” style, having the word is acceptable.

    Ordering and Completeness: The browser view should likely reflect the actual model containment structure. It looks like it did: VehicleProject contains Definitions, Requirements, Views, etc. Then under Views, you listed SafetyConcern, SafetyViewpoint, SafetyView – presumably those are contained in the Views package. Good. Ensure that all elements appear under the correct owners. For instance, vehicle1 (the part usage) might not appear in this tree – and that’s fine if it’s an instance and your model’s containment might not list it at the package level. If it belongs under some “VehicleSystem” definition in the hierarchy, you could list it there. But often instance-level things are not shown in a package hierarchy tree. That’s up to you – just be consistent.

    Use of Browser View: The browser view is mostly for navigation and doesn’t have “behavior” on its own. As a static diagram, it serves as a quick index to the model elements. You might use it at the start of documentation to give an overview of the model contents. Visually, it’s nearly there – just a bit more polish on alignment and maybe an icon legend. Given SysML v2’s Browser view is exactly to show membership hierarchy

    , your implementation is on point. It just needs the same attention to consistency as the other diagrams.

    Font and Spacing: Possibly use a smaller font for the browser view if it’s a large model, to fit more levels. But ensure it’s readable. If an element name is very long, you might allow text wrapping or truncate it with an ellipsis for the view (since a browser tree might truncate). That’s an edge case to consider.

Overall, the Browser view diagram looked good and mostly just needs minor alignment fixes. It’s already following a known convention (plus/minus tree nodes). Bringing it to a polished state will give users a familiar “project explorer” feel.
General Suggestions for Layout Algorithms

Many of the layout improvements above might be achieved by leveraging or tweaking layout algorithms:

    Automated Layout Tools: If you find manual fine-tuning of positions too cumbersome, consider integrating an automatic graph layout engine for certain views. For example, hierarchical layout algorithms (like those in Graphviz’s dot or the Eclipse ELK library) are well-suited for state machines, activity diagrams, and block definition structures, where relationships are mostly directed. There are JavaScript implementations (e.g., elkjs for ELK or dagre for DAG layout) that could help compute positions for nodes to minimize overlaps and crossings. For instance, ELK could arrange a state machine’s states in layers (initial state at top, final at bottom) automatically, or arrange an activity flow left-to-right for concurrent branches. You might still need to tweak the output, but it can handle a lot of the heavy lifting for you.

    JointJS or Diagram Libraries: It appears you might be using some diagramming library (the presence of vite and possibly references to JointJS in your repo). If so, explore that library’s built-in layout or routing options. Many allow orthogonal (Manhattan) routing for connectors, which can greatly tidy up interconnection diagrams and activity flows by keeping lines at right angles and avoiding node overlaps. JointJS, for example, has an orthogonal connector router and support for magnets (ports) on shapes which would directly assist in linking ports between blocks.

    Custom Heuristics: For sequence diagrams, you can implement a straightforward calculation: assign each lifeline an x-coordinate (evenly spaced), and each message a y-coordinate in increasing order. This is simpler than a generic graph layout and ensures correct ordering. For state diagrams, a simple heuristic is to place states in a circle or grid and then adjust to reduce crossing – but a specialized algorithm yields the best result. For activity diagrams, layering by control flow depth (like a flowchart top to bottom) works: start nodes at top, then actions and decisions in order, parallel branches side-by-side, and merge at bottom.

    User Adjustments: If this is an interactive web visualization (the name web-vis hints it might be), consider allowing the user to drag and reposition nodes, and then maybe save those coordinates. Many modeling tools allow manual fine-tuning because automatic layouts can’t read the modeler’s mind for all aesthetics. If you provide at least a decent initial layout (using algorithms as above), a user could tweak. For static outputs (like generating PNGs via tests), you have to aim for a generally pleasing layout for all foreseeable cases, which is challenging but doable with the above guidelines.

    Spacing and Scaling: Leave enough spacing between elements so that labels have room. In some test images, text was cramped (e.g., the state “Active” had a lot of text inside). Increase the default padding inside state or action boxes so text doesn’t hit the borders. Similarly, leave margins around the diagram frame so that no text or arrow touches the edge of the image (in GeneralView, the “PriorityTag” box was partly cut off at the right edge – adding a margin or auto-expanding the canvas would fix that).

    Consistent Diagram Size: Ensure that each diagram view, when exported, is properly scaled – for example, all text is legible (not too small). It might be beneficial to output SVGs (which you have) for infinite scaling, and PNGs for quick looks. The PNGs in tests were somewhat small; consider generating higher-resolution PNGs or let the user zoom.

By addressing these layout and notation points, your SysML visualizations will adhere much more closely to SysML v2 conventions and best practices. The improvements will make the diagrams not only look more professional but also reduce ambiguity (which is crucial in a modeling context). Great job on the progress so far – incorporating these changes will significantly elevate the quality and usability of your SysML v2 diagramming library, bringing it in line with the expectations set by SysML v2’s specification and tooling guides.

Each diagram should then clearly communicate its intent: the General view giving an overarching static picture, the Interconnection view detailing internal part connections, the Action flows and State transitions illustrating behavior flows, the Sequence view showing interactions over time, and the Grid/Browser views providing alternative perspectives for traceability and structure

. By following the official conventions and our recommendations, users of your tool will find the visuals familiar and intuitive, matching what they’d expect from SysML v2 diagrams in other professional tools. Good luck with the next iteration of improvements!

Sources:

    SodiusWillert SysML v2 Cheat Sheet – naming conventions and model structuring tips

Stephan Roth’s SysML v2 blog – definition vs usage notation (sharp vs rounded corners)

D. Rajamani, Key Differences Between SysML v1 and v2 – terminology changes and view concepts

SysML Specification Tutorials – diagram frames and headers (SysML 1.x practice, still relevant)

MBSE SysON Documentation – descriptions of SysML v2 views (sequence, grid, browser, etc.)

Visual Paradigm Guide to Sequence Diagrams – standard lifeline and message notation (applies to SysML interactions)
Citations

SysML v2 Definition vs. Usage: What's It All About? | Stephan Roth
https://roth-soft.de/blog/2025-08-23-sysml-2-definition-usage.html

https://www.sodiuswillert.com/hubfs/Downloadables/SodiusWillertSysMLv2CheatSheet.pdf

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Briefing at introductory meeting with AFIT students and Advisor
https://www.jhuapl.edu/sites/default/files/2023-03/ModelingwithSysMLTutorial.pdf

Briefing at introductory meeting with AFIT students and Advisor
https://www.jhuapl.edu/sites/default/files/2023-03/ModelingwithSysMLTutorial.pdf

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

https://www.sodiuswillert.com/hubfs/Downloadables/SodiusWillertSysMLv2CheatSheet.pdf

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Key Differences Between SysML v1 and SysML v2 | by Dinesh Kumar Rajamani | Medium
https://dinesh-kumar-rajamani.medium.com/key-differences-between-sysml-v1-and-sysml-v2-b035d4e3faad

Overview of SysML v2 :: SysON Docs
https://doc.mbse-syson.org/syson/v2025.10.0/user-manual/features/sysmlv2-overview.html

Overview of SysML v2 :: SysON Docs
https://doc.mbse-syson.org/syson/v2025.10.0/user-manual/features/sysmlv2-overview.html

SysML: Modeling Scenarios with Sequence Diagram
https://www.visual-paradigm.com/guide/sysml/modeling-scenarios-with-sequence-diagram/1000

Overview of SysML v2 :: SysON Docs
https://doc.mbse-syson.org/syson/v2025.10.0/user-manual/features/sysmlv2-overview.html

Overview of SysML v2 :: SysON Docs
https://doc.mbse-syson.org/syson/v2025.10.0/user-manual/features/sysmlv2-overview.html
