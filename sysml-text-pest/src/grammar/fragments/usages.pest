// =============================================================================
// USAGES
// =============================================================================

UsageElement = {
    NonOccurrenceUsageElement
    | OccurrenceUsageElement
}

// DefaultReferenceUsage MUST come first - it matches usages without explicit keyword
// like "in x: Type" or "out y[0..*]: SomeType"
NonOccurrenceUsageElement = {
    DefaultReferenceUsage
    | ReferenceUsage
    | AttributeUsage
    | EnumerationUsage
    | BindingConnectorAsUsage
    | SuccessionAsUsage
    | ExtendedUsage
    // KerML feature types (for standard library parsing)
    | StepUsage
    | ExpressionUsage
    | BooleanExpressionUsage
    | InvariantUsage
    // KerML connector types (for standard library parsing)
    | Connector
    | BindingConnector
    | Succession
}

OccurrenceUsageElement = {
    StructureUsageElement
    | BehaviorUsageElement
}

StructureUsageElement = {
    OccurrenceUsage
    | IndividualUsage
    | PortionUsage
    | EventOccurrenceUsage
    | ItemUsage
    | PartUsage
    | PortUsage
    | ConnectionUsage
    | InterfaceUsage
    | AllocationUsage
    | SuccessionFlowUsage
    | FlowConnectionUsage
    | MessageUsage
    | ViewUsage
    | RenderingUsage
}

BehaviorUsageElement = {
    ActionUsage
    | CalculationUsage
    | StateUsage
    | ConstraintUsage
    | RequirementUsage
    | ConcernUsage
    | CaseUsage
    | AnalysisCaseUsage
    | VerificationCaseUsage
    | UseCaseUsage
    | ViewpointUsage
    | PerformActionUsage
    | ExhibitStateUsage
    | IncludeUseCaseUsage
    | AssertConstraintUsage
    | SatisfyRequirementUsage
}

VariantUsageElement = {
    VariantReference
    | NonOccurrenceUsageElement
    | OccurrenceUsageElement
}

VariantReference = { OwnedReferenceSubsetting ~ FeatureSpecialization* ~ UsageBody }

// Usage prefixes
UsagePrefix = { UnextendedUsagePrefix ~ UsageExtensionKeyword* }
UnextendedUsagePrefix = { EndUsagePrefix | BasicUsagePrefix }
BasicUsagePrefix = { RefPrefix ~ Reference? }
// KerML BasicFeaturePrefix: direction? derived? abstract? (composite|portion)? (var|const)?
// Note: FeaturePortion (the 'portion' keyword) is distinct from Portion (which is PortionKind: timeslice|snapshot)
RefPrefix = {
    FeatureDirectionKind? ~
    Derived? ~
    BasicDefinitionPrefix? ~
    (Composite | FeaturePortion)? ~
    (Variable | Constant)? ~
    Readonly?
}
Reference = { KW_REF }
EndUsagePrefix = { End ~ OwnedCrossingFeatureMember? }
UsageExtensionKeyword = { PrefixMetadataMember }
// OwnedCrossingFeatureMember must NOT match usage keywords (occurrence, port, etc.)
// It's only for cross-features with explicit prefix modifiers (in/out/ref/etc.)
OwnedCrossingFeatureMember = { !UsageKeywordLookahead ~ OwnedCrossingFeature }
// OwnedCrossingFeature: [prefix] declaration
// Per KerML.xtext: BasicFeaturePrefix FeatureDeclaration
// The nested 'feature' keyword belongs to the OUTER Feature rule, not here
OwnedCrossingFeature = { BasicUsagePrefix? ~ UsageDeclaration }

// Lookahead for usage keywords that should NOT be consumed by OwnedCrossingFeatureMember
// or DefaultReferenceUsage (prevents keywords from being parsed as identifiers)
UsageKeywordLookahead = {
    KW_OCCURRENCE | KW_ITEM | KW_PART | KW_PORT | KW_CONNECTION |
    KW_INTERFACE | KW_ALLOCATION | KW_FLOW | KW_ACTION | KW_STATE |
    KW_CONSTRAINT | KW_REQUIREMENT | KW_CONCERN | KW_CASE | KW_ANALYSIS |
    KW_VERIFICATION | KW_VIEW | KW_VIEWPOINT | KW_RENDERING | KW_EVENT |
    KW_ATTRIBUTE | KW_ENUM | KW_CALC | KW_REF | KW_SUCCESSION | KW_BIND |
    KW_BINDING | KW_ALLOCATE | KW_CONNECT | KW_PERFORM | KW_EXHIBIT |
    KW_INCLUDE | KW_SATISFY | KW_ASSERT | KW_USE |
    // Actor/Subject/Stakeholder keywords (for package body extension)
    KW_ACTOR | KW_SUBJECT | KW_STAKEHOLDER |
    // KW_FEATURE for "end feature" pattern (prevents OwnedCrossingFeatureMember from consuming)
    KW_FEATURE
}

UsageDeclaration = { FeatureDeclaration }

UsageCompletion = { ValuePart? ~ UsageBody }

UsageBody = { DefinitionBody }

// Specific usages
ReferenceUsage = {
    (EndUsagePrefix | RefPrefix) ~ KW_REF ~ UsageDeclaration? ~ UsageCompletion
}

// !UsageKeywordLookahead prevents matching when usage keyword follows (e.g., "inout part x")
// Otherwise DefaultReferenceUsage would match "inout" and treat "part" as an identifier name
DefaultReferenceUsage = {
    End? ~ RefPrefix ~ !UsageKeywordLookahead ~ UsageDeclaration? ~ UsageCompletion
}

AttributeUsage = {
    UsagePrefix ~ KW_ATTRIBUTE ~ UsageDeclaration? ~ UsageCompletion
}

EnumerationUsage = {
    UsagePrefix ~ KW_ENUM ~ UsageDeclaration? ~ UsageCompletion
}

OccurrenceUsage = {
    OccurrenceUsagePrefix ~ KW_OCCURRENCE ~ UsageDeclaration? ~ UsageCompletion
}

OccurrenceUsagePrefix = {
    (EndUsagePrefix | BasicOccurrenceUsagePrefix) ~ UsageExtensionKeyword*
}

BasicOccurrenceUsagePrefix = { BasicUsagePrefix ~ Individual? ~ Portion? }

Portion = { PortionKind }

IndividualUsage = {
    BasicUsagePrefix ~ Individual ~ UsageExtensionKeyword* ~ UsageDeclaration? ~ UsageCompletion
}

PortionUsage = {
    BasicUsagePrefix ~ Individual? ~ Portion ~ UsageExtensionKeyword* ~ UsageDeclaration? ~ UsageCompletion
}

EventOccurrenceUsage = {
    OccurrenceUsagePrefix ~ KW_EVENT ~ (
        // KW_OCCURRENCE must come first - otherwise "occurrence" matches as QualifiedName
        KW_OCCURRENCE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ UsageCompletion
}

ItemUsage = {
    OccurrenceUsagePrefix ~ KW_ITEM ~ UsageDeclaration? ~ UsageCompletion
}

PartUsage = {
    OccurrenceUsagePrefix ~ KW_PART ~ UsageDeclaration? ~ UsageCompletion
}

PortUsage = {
    OccurrenceUsagePrefix ~ KW_PORT ~ UsageDeclaration? ~ UsageCompletion
}

ConnectionUsage = {
    OccurrenceUsagePrefix ~ (
        KW_CONNECTION ~ UsageDeclaration? ~ ValuePart? ~ (KW_CONNECT ~ ConnectorPart)?
        | KW_CONNECT ~ ConnectorPart
    ) ~ UsageBody
}

ConnectorPart = { BinaryConnectorPart | NaryConnectorPart }

BinaryConnectorPart = { ConnectorEndMember ~ KW_TO ~ ConnectorEndMember }

NaryConnectorPart = { "(" ~ ConnectorEndMember ~ ("," ~ ConnectorEndMember)+ ~ ")" }

ConnectorEndMember = { ConnectorEnd }

ConnectorEnd = {
    OwnedCrossMultiplicityMember? ~ (RegularName ~ ReferencesToken)? ~ OwnedReferenceSubsetting
}

OwnedCrossMultiplicityMember = { OwnedCrossMultiplicity }

OwnedCrossMultiplicity = { OwnedMultiplicity }

InterfaceUsage = {
    OccurrenceUsagePrefix ~ KW_INTERFACE ~ UsageDeclaration? ~ (KW_CONNECT ~ InterfacePart)? ~ InterfaceBody
}

InterfacePart = { BinaryInterfacePart | NaryInterfacePart }

BinaryInterfacePart = { InterfaceEndMember ~ KW_TO ~ InterfaceEndMember }

NaryInterfacePart = { "(" ~ InterfaceEndMember ~ ("," ~ InterfaceEndMember)+ ~ ")" }

InterfaceEndMember = { InterfaceEnd }

InterfaceEnd = {
    OwnedCrossMultiplicityMember? ~ (RegularName ~ ReferencesToken)? ~ OwnedReferenceSubsetting
}

AllocationUsage = {
    OccurrenceUsagePrefix ~ (
        KW_ALLOCATION ~ UsageDeclaration? ~ (KW_ALLOCATE ~ ConnectorPart)?
        | KW_ALLOCATE ~ ConnectorPart
    ) ~ UsageBody
}

FlowConnectionUsage = {
    OccurrenceUsagePrefix ~ KW_FLOW ~ FlowConnectionDeclaration ~ DefinitionBody
}

SuccessionFlowUsage = {
    OccurrenceUsagePrefix ~ KW_SUCCESSION ~ KW_FLOW ~ FlowConnectionDeclaration ~ DefinitionBody
}

MessageUsage = {
    OccurrenceUsagePrefix ~ KW_MESSAGE ~ MessageDeclaration ~ DefinitionBody
}

MessageDeclaration = {
    MessageEventMember ~ KW_TO ~ MessageEventMember
    | UsageDeclaration? ~ ValuePart? ~ (KW_OF ~ PayloadFeatureMember)? ~
        (KW_FROM ~ MessageEventMember ~ KW_TO ~ MessageEventMember)?
}

PayloadFeatureMember = { ItemFeature }

MessageEventMember = { OwnedExpression }

// FlowConnectionDeclaration: Ordered alternatives for PEG
// CRITICAL: Try keyword-starting patterns FIRST to prevent keywords being parsed as identifiers
FlowConnectionDeclaration = {
    // Pattern 1: Bare 'from a.x to b.y'
    KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 2: 'of item from ... to ...' (no declaration)
    | KW_OF ~ ItemFeatureMember ~ KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 3: 'of item' only (no endpoints)
    | KW_OF ~ ItemFeatureMember
    // Pattern 4: With declaration then 'from'
    | UsageDeclaration ~ ValuePart? ~ (KW_OF ~ ItemFeatureMember)? ~
        KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 5: With declaration then 'of' then 'from'
    | UsageDeclaration ~ ValuePart? ~ KW_OF ~ ItemFeatureMember ~
        KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 6: Direct endpoints 'a.x to b.y' (no 'from')
    | FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 7: Declaration with optional 'of' (no endpoints)
    | UsageDeclaration ~ ValuePart? ~ (KW_OF ~ ItemFeatureMember)?
}

ItemFeatureMember = { ItemFeature }

ItemFeature = {
    Identification? ~ PayloadFeatureSpecializationPart ~ ValuePart?
    | Identification? ~ ValuePart
    | OwnedFeatureTyping ~ OwnedMultiplicity?
    | OwnedMultiplicity ~ OwnedFeatureTyping
}

PayloadFeatureSpecializationPart = {
    FeatureSpecialization+ ~ (MultiplicityPart ~ FeatureSpecialization*)?
    | MultiplicityPart ~ FeatureSpecialization+
}

FlowEndMember = { FlowEnd }

FlowEnd = { FlowEndSubsetting? ~ FlowFeatureMember }

FlowEndSubsetting = { QualifiedName ~ "." | FeatureChainPrefix }

FlowFeatureMember = { FlowFeature }

FlowFeature = { FlowRedefinition }

FlowRedefinition = { QualifiedName }

ViewUsage = {
    OccurrenceUsagePrefix ~ KW_VIEW ~ UsageDeclaration? ~ ValuePart? ~ ViewBody
}

RenderingUsage = {
    OccurrenceUsagePrefix ~ KW_RENDERING ~ UsageDeclaration? ~ UsageCompletion
}

ActionUsage = {
    OccurrenceUsagePrefix ~ KW_ACTION ~ UsageDeclaration? ~ ValuePart? ~ ActionBody
}

PerformActionUsage = {
    OccurrenceUsagePrefix ~ KW_PERFORM ~ (
        KW_ACTION ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ ActionBody
}

CalculationUsage = {
    OccurrenceUsagePrefix ~ KW_CALC ~ UsageDeclaration? ~ ValuePart? ~ CalculationBody
}

StateUsage = {
    OccurrenceUsagePrefix ~ KW_STATE ~ UsageDeclaration? ~ ValuePart? ~ StateBody
}

ExhibitStateUsage = {
    OccurrenceUsagePrefix ~ KW_EXHIBIT ~ (
        KW_STATE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ StateBody
}

ConstraintUsage = {
    OccurrenceUsagePrefix ~ KW_CONSTRAINT ~ UsageDeclaration? ~ ValuePart? ~ CalculationBody
}

AssertConstraintUsage = {
    OccurrenceUsagePrefix ~ KW_ASSERT ~ KW_NOT? ~ (
        KW_CONSTRAINT ~ UsageDeclaration? ~ ValuePart?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ CalculationBody
}

RequirementUsage = {
    OccurrenceUsagePrefix ~ KW_REQUIREMENT ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

SatisfyRequirementUsage = {
    OccurrenceUsagePrefix ~ KW_ASSERT? ~ KW_NOT? ~ KW_SATISFY ~ (
        KW_REQUIREMENT ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ (KW_BY ~ SatisfactionSubjectMember)? ~ RequirementBody
}

SatisfactionSubjectMember = { SatisfactionParameter }

SatisfactionParameter = { SatisfactionFeatureValue }

SatisfactionFeatureValue = { OwnedExpression }

ConcernUsage = {
    OccurrenceUsagePrefix ~ KW_CONCERN ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

CaseUsage = {
    OccurrenceUsagePrefix ~ KW_CASE ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

AnalysisCaseUsage = {
    OccurrenceUsagePrefix ~ KW_ANALYSIS ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

VerificationCaseUsage = {
    OccurrenceUsagePrefix ~ KW_VERIFICATION ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

UseCaseUsage = {
    OccurrenceUsagePrefix ~ KW_USE ~ KW_CASE ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

IncludeUseCaseUsage = {
    OccurrenceUsagePrefix ~ KW_INCLUDE ~ (
        KW_USE ~ KW_CASE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ CaseBody
}

ViewpointUsage = {
    OccurrenceUsagePrefix ~ KW_VIEWPOINT ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

BindingConnectorAsUsage = {
    UsagePrefix ~ (KW_BINDING ~ UsageDeclaration?)? ~
    KW_BIND ~ ConnectorEndMember ~ "=" ~ ConnectorEndMember ~ DefinitionBody
}

SuccessionAsUsage = {
    UsagePrefix ~ (KW_SUCCESSION ~ UsageDeclaration?)? ~
    KW_FIRST ~ ConnectorEndMember ~ KW_THEN ~ ConnectorEndMember ~ DefinitionBody
}

ExtendedUsage = {
    UnextendedUsagePrefix ~ UsageExtensionKeyword+ ~ UsageDeclaration? ~ UsageCompletion
}

// =============================================================================
// KERML FEATURE USAGES (for standard library parsing)
// =============================================================================

// KerML Step: [modifiers] step [name] [: Type] [= value] { ... } | ;
StepUsage = {
    UsagePrefix ~ KW_STEP ~ UsageDeclaration? ~ ValuePart? ~ DefinitionBody
}

// KerML Expression: [modifiers] expr [name] [: Type] [= value] { ... } | ;
ExpressionUsage = {
    UsagePrefix ~ KW_EXPR ~ UsageDeclaration? ~ ValuePart? ~ FunctionBody
}

// KerML BooleanExpression: [modifiers] bool [name] [: Type] [= value] { ... } | ;
BooleanExpressionUsage = {
    UsagePrefix ~ KW_BOOL ~ UsageDeclaration? ~ ValuePart? ~ FunctionBody
}

// KerML Invariant: [modifiers] inv [true|false] [name] [: Type] [= value] { ... } | ;
InvariantUsage = {
    UsagePrefix ~ KW_INV ~ (KW_TRUE | KW_FALSE)? ~ UsageDeclaration? ~ ValuePart? ~ FunctionBody
}

// =============================================================================
// KERML CONNECTORS (for standard library parsing)
// =============================================================================

// KerML Connector: [modifiers] connector [decl] [from end to end | (end, end+)] { } | ;
// Per KerML.xtext lines 824-844
// Supports:
// - connector : Type from [1] self to [1] this;  (binary with typing)
// - connector name from ref to ref;              (binary with name)
// - connector all from ref to ref;               (sufficient binary)
// - connector (ref, ref);                        (n-ary)
// - connector name : Type { }                    (plain declaration)
Connector = {
    UsagePrefix ~ KW_CONNECTOR ~ (
        // Binary connector: [decl] from end to end
        FeatureDeclaration? ~ KW_FROM ~ ConnectorEndMember ~ KW_TO ~ ConnectorEndMember
        // Sufficient binary: all [from] end to end
        | Sufficient ~ KW_FROM? ~ ConnectorEndMember ~ KW_TO ~ ConnectorEndMember
        // N-ary connector: [decl] (end, end, ...)
        | FeatureDeclaration? ~ "(" ~ ConnectorEndMember ~ ("," ~ ConnectorEndMember)+ ~ ")"
        // Plain declaration (no from/to) - must be last as it's the fallback
        | FeatureDeclaration? ~ ValuePart?
    ) ~ DefinitionBody
}

// KerML BindingConnector: [modifiers] binding [decl] [of end = end] { } | ;
// Per KerML.xtext lines 867-879:
//   BindingConnectorDeclaration:
//     FeatureDeclaration ('of' end '=' end)?
//   | (all)? (of? end = end)?
//
// IMPORTANT: PEG order matters. Try anonymous form first when we see `[` (multiplicity)
// since that could be ConnectorEnd's OwnedCrossMultiplicity, not FeatureDeclaration's multiplicity.
BindingConnector = {
    UsagePrefix ~ KW_BINDING ~ (
        // Pattern 1: Named with 'of' (e.g., "binding oSelf of x.a = y.b")
        // Must have identifier (not just multiplicity) before 'of'
        Identification ~ FeatureSpecializationPart? ~ FeatureRelationshipPart* ~ KW_OF ~ ConnectorEndMember ~ "=" ~ ConnectorEndMember
        // Pattern 2: Anonymous binding [all] [of] end = end (e.g., "binding [1] startShot = [1] endShot")
        | Sufficient? ~ KW_OF? ~ ConnectorEndMember ~ "=" ~ ConnectorEndMember
        // Pattern 3: Named declaration only (e.g., "binding oSelf;")
        | FeatureDeclaration ~ ValuePart?
    ) ~ DefinitionBody
}

// KerML Succession: [modifiers] succession [decl] [first end then end] { } | ;
// Per KerML.xtext lines 881-895
Succession = {
    UsagePrefix ~ KW_SUCCESSION ~ (
        // Succession form: [first] end then end
        KW_FIRST? ~ ConnectorEndMember ~ KW_THEN ~ ConnectorEndMember
        // Plain declaration
        | FeatureDeclaration? ~ ValuePart?
    ) ~ DefinitionBody
}
