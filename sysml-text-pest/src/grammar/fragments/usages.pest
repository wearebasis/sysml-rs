// =============================================================================
// USAGES
// =============================================================================

UsageElement = {
    NonOccurrenceUsageElement
    | OccurrenceUsageElement
}

// DefaultReferenceUsage MUST come first - it matches usages without explicit keyword
// like "in x: Type" or "out y[0..*]: SomeType"
NonOccurrenceUsageElement = {
    DefaultReferenceUsage
    | ReferenceUsage
    | AttributeUsage
    | EnumerationUsage
    | BindingConnectorAsUsage
    | SuccessionAsUsage
    | ExtendedUsage
}

OccurrenceUsageElement = {
    StructureUsageElement
    | BehaviorUsageElement
}

StructureUsageElement = {
    OccurrenceUsage
    | IndividualUsage
    | PortionUsage
    | EventOccurrenceUsage
    | ItemUsage
    | PartUsage
    | PortUsage
    | ConnectionUsage
    | InterfaceUsage
    | AllocationUsage
    | SuccessionFlowUsage
    | FlowConnectionUsage
    | MessageUsage
    | ViewUsage
    | RenderingUsage
}

BehaviorUsageElement = {
    ActionUsage
    | CalculationUsage
    | StateUsage
    | ConstraintUsage
    | RequirementUsage
    | ConcernUsage
    | CaseUsage
    | AnalysisCaseUsage
    | VerificationCaseUsage
    | UseCaseUsage
    | ViewpointUsage
    | PerformActionUsage
    | ExhibitStateUsage
    | IncludeUseCaseUsage
    | AssertConstraintUsage
    | SatisfyRequirementUsage
}

VariantUsageElement = {
    VariantReference
    | NonOccurrenceUsageElement
    | OccurrenceUsageElement
}

VariantReference = { OwnedReferenceSubsetting ~ FeatureSpecialization* ~ UsageBody }

// Usage prefixes
UsagePrefix = { UnextendedUsagePrefix ~ UsageExtensionKeyword* }
UnextendedUsagePrefix = { EndUsagePrefix | BasicUsagePrefix }
BasicUsagePrefix = { RefPrefix ~ Reference? }
RefPrefix = { FeatureDirectionKind? ~ BasicDefinitionPrefix? ~ Readonly? ~ Derived? }
Reference = { KW_REF }
EndUsagePrefix = { End ~ OwnedCrossingFeatureMember? }
UsageExtensionKeyword = { PrefixMetadataMember }
// OwnedCrossingFeatureMember must NOT match usage keywords (occurrence, port, etc.)
// It's only for cross-features with explicit prefix modifiers (in/out/ref/etc.)
OwnedCrossingFeatureMember = { !UsageKeywordLookahead ~ OwnedCrossingFeature }
OwnedCrossingFeature = { BasicUsagePrefix? ~ UsageDeclaration }

// Lookahead for usage keywords that should NOT be consumed by OwnedCrossingFeatureMember
// or DefaultReferenceUsage (prevents keywords from being parsed as identifiers)
UsageKeywordLookahead = {
    KW_OCCURRENCE | KW_ITEM | KW_PART | KW_PORT | KW_CONNECTION |
    KW_INTERFACE | KW_ALLOCATION | KW_FLOW | KW_ACTION | KW_STATE |
    KW_CONSTRAINT | KW_REQUIREMENT | KW_CONCERN | KW_CASE | KW_ANALYSIS |
    KW_VERIFICATION | KW_VIEW | KW_VIEWPOINT | KW_RENDERING | KW_EVENT |
    KW_ATTRIBUTE | KW_ENUM | KW_CALC | KW_REF | KW_SUCCESSION | KW_BIND |
    KW_BINDING | KW_ALLOCATE | KW_CONNECT | KW_PERFORM | KW_EXHIBIT |
    KW_INCLUDE | KW_SATISFY | KW_ASSERT | KW_USE |
    // Actor/Subject/Stakeholder keywords (for package body extension)
    KW_ACTOR | KW_SUBJECT | KW_STAKEHOLDER
}

UsageDeclaration = { FeatureDeclaration }

UsageCompletion = { ValuePart? ~ UsageBody }

UsageBody = { DefinitionBody }

// Specific usages
ReferenceUsage = {
    (EndUsagePrefix | RefPrefix) ~ KW_REF ~ UsageDeclaration? ~ UsageCompletion
}

// !UsageKeywordLookahead prevents matching when usage keyword follows (e.g., "inout part x")
// Otherwise DefaultReferenceUsage would match "inout" and treat "part" as an identifier name
DefaultReferenceUsage = {
    End? ~ RefPrefix ~ !UsageKeywordLookahead ~ UsageDeclaration? ~ UsageCompletion
}

AttributeUsage = {
    UsagePrefix ~ KW_ATTRIBUTE ~ UsageDeclaration? ~ UsageCompletion
}

EnumerationUsage = {
    UsagePrefix ~ KW_ENUM ~ UsageDeclaration? ~ UsageCompletion
}

OccurrenceUsage = {
    OccurrenceUsagePrefix ~ KW_OCCURRENCE ~ UsageDeclaration? ~ UsageCompletion
}

OccurrenceUsagePrefix = {
    (EndUsagePrefix | BasicOccurrenceUsagePrefix) ~ UsageExtensionKeyword*
}

BasicOccurrenceUsagePrefix = { BasicUsagePrefix ~ Individual? ~ Portion? }

Portion = { PortionKind }

IndividualUsage = {
    BasicUsagePrefix ~ Individual ~ UsageExtensionKeyword* ~ UsageDeclaration? ~ UsageCompletion
}

PortionUsage = {
    BasicUsagePrefix ~ Individual? ~ Portion ~ UsageExtensionKeyword* ~ UsageDeclaration? ~ UsageCompletion
}

EventOccurrenceUsage = {
    OccurrenceUsagePrefix ~ KW_EVENT ~ (
        // KW_OCCURRENCE must come first - otherwise "occurrence" matches as QualifiedName
        KW_OCCURRENCE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ UsageCompletion
}

ItemUsage = {
    OccurrenceUsagePrefix ~ KW_ITEM ~ UsageDeclaration? ~ UsageCompletion
}

PartUsage = {
    OccurrenceUsagePrefix ~ KW_PART ~ UsageDeclaration? ~ UsageCompletion
}

PortUsage = {
    OccurrenceUsagePrefix ~ KW_PORT ~ UsageDeclaration? ~ UsageCompletion
}

ConnectionUsage = {
    OccurrenceUsagePrefix ~ (
        KW_CONNECTION ~ UsageDeclaration? ~ ValuePart? ~ (KW_CONNECT ~ ConnectorPart)?
        | KW_CONNECT ~ ConnectorPart
    ) ~ UsageBody
}

ConnectorPart = { BinaryConnectorPart | NaryConnectorPart }

BinaryConnectorPart = { ConnectorEndMember ~ KW_TO ~ ConnectorEndMember }

NaryConnectorPart = { "(" ~ ConnectorEndMember ~ ("," ~ ConnectorEndMember)+ ~ ")" }

ConnectorEndMember = { ConnectorEnd }

ConnectorEnd = {
    OwnedCrossMultiplicityMember? ~ (RegularName ~ ReferencesToken)? ~ OwnedReferenceSubsetting
}

OwnedCrossMultiplicityMember = { OwnedCrossMultiplicity }

OwnedCrossMultiplicity = { OwnedMultiplicity }

InterfaceUsage = {
    OccurrenceUsagePrefix ~ KW_INTERFACE ~ UsageDeclaration? ~ (KW_CONNECT ~ InterfacePart)? ~ InterfaceBody
}

InterfacePart = { BinaryInterfacePart | NaryInterfacePart }

BinaryInterfacePart = { InterfaceEndMember ~ KW_TO ~ InterfaceEndMember }

NaryInterfacePart = { "(" ~ InterfaceEndMember ~ ("," ~ InterfaceEndMember)+ ~ ")" }

InterfaceEndMember = { InterfaceEnd }

InterfaceEnd = {
    OwnedCrossMultiplicityMember? ~ (RegularName ~ ReferencesToken)? ~ OwnedReferenceSubsetting
}

AllocationUsage = {
    OccurrenceUsagePrefix ~ (
        KW_ALLOCATION ~ UsageDeclaration? ~ (KW_ALLOCATE ~ ConnectorPart)?
        | KW_ALLOCATE ~ ConnectorPart
    ) ~ UsageBody
}

FlowConnectionUsage = {
    OccurrenceUsagePrefix ~ KW_FLOW ~ FlowConnectionDeclaration ~ DefinitionBody
}

SuccessionFlowUsage = {
    OccurrenceUsagePrefix ~ KW_SUCCESSION ~ KW_FLOW ~ FlowConnectionDeclaration ~ DefinitionBody
}

MessageUsage = {
    OccurrenceUsagePrefix ~ KW_MESSAGE ~ MessageDeclaration ~ DefinitionBody
}

MessageDeclaration = {
    MessageEventMember ~ KW_TO ~ MessageEventMember
    | UsageDeclaration? ~ ValuePart? ~ (KW_OF ~ PayloadFeatureMember)? ~
        (KW_FROM ~ MessageEventMember ~ KW_TO ~ MessageEventMember)?
}

PayloadFeatureMember = { ItemFeature }

MessageEventMember = { OwnedExpression }

// FlowConnectionDeclaration: Ordered alternatives for PEG
// CRITICAL: Try keyword-starting patterns FIRST to prevent keywords being parsed as identifiers
FlowConnectionDeclaration = {
    // Pattern 1: Bare 'from a.x to b.y'
    KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 2: 'of item from ... to ...' (no declaration)
    | KW_OF ~ ItemFeatureMember ~ KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 3: 'of item' only (no endpoints)
    | KW_OF ~ ItemFeatureMember
    // Pattern 4: With declaration then 'from'
    | UsageDeclaration ~ ValuePart? ~ (KW_OF ~ ItemFeatureMember)? ~
        KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 5: With declaration then 'of' then 'from'
    | UsageDeclaration ~ ValuePart? ~ KW_OF ~ ItemFeatureMember ~
        KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 6: Direct endpoints 'a.x to b.y' (no 'from')
    | FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 7: Declaration with optional 'of' (no endpoints)
    | UsageDeclaration ~ ValuePart? ~ (KW_OF ~ ItemFeatureMember)?
}

ItemFeatureMember = { ItemFeature }

ItemFeature = {
    Identification? ~ PayloadFeatureSpecializationPart ~ ValuePart?
    | Identification? ~ ValuePart
    | OwnedFeatureTyping ~ OwnedMultiplicity?
    | OwnedMultiplicity ~ OwnedFeatureTyping
}

PayloadFeatureSpecializationPart = {
    FeatureSpecialization+ ~ (MultiplicityPart ~ FeatureSpecialization*)?
    | MultiplicityPart ~ FeatureSpecialization+
}

FlowEndMember = { FlowEnd }

FlowEnd = { FlowEndSubsetting? ~ FlowFeatureMember }

FlowEndSubsetting = { QualifiedName ~ "." | FeatureChainPrefix }

FlowFeatureMember = { FlowFeature }

FlowFeature = { FlowRedefinition }

FlowRedefinition = { QualifiedName }

ViewUsage = {
    OccurrenceUsagePrefix ~ KW_VIEW ~ UsageDeclaration? ~ ValuePart? ~ ViewBody
}

RenderingUsage = {
    OccurrenceUsagePrefix ~ KW_RENDERING ~ UsageDeclaration? ~ UsageCompletion
}

ActionUsage = {
    OccurrenceUsagePrefix ~ KW_ACTION ~ UsageDeclaration? ~ ValuePart? ~ ActionBody
}

PerformActionUsage = {
    OccurrenceUsagePrefix ~ KW_PERFORM ~ (
        KW_ACTION ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ ActionBody
}

CalculationUsage = {
    OccurrenceUsagePrefix ~ KW_CALC ~ UsageDeclaration? ~ ValuePart? ~ CalculationBody
}

StateUsage = {
    OccurrenceUsagePrefix ~ KW_STATE ~ UsageDeclaration? ~ ValuePart? ~ StateBody
}

ExhibitStateUsage = {
    OccurrenceUsagePrefix ~ KW_EXHIBIT ~ (
        KW_STATE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ StateBody
}

ConstraintUsage = {
    OccurrenceUsagePrefix ~ KW_CONSTRAINT ~ UsageDeclaration? ~ ValuePart? ~ CalculationBody
}

AssertConstraintUsage = {
    OccurrenceUsagePrefix ~ KW_ASSERT ~ KW_NOT? ~ (
        KW_CONSTRAINT ~ UsageDeclaration? ~ ValuePart?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ CalculationBody
}

RequirementUsage = {
    OccurrenceUsagePrefix ~ KW_REQUIREMENT ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

SatisfyRequirementUsage = {
    OccurrenceUsagePrefix ~ KW_ASSERT? ~ KW_NOT? ~ KW_SATISFY ~ (
        KW_REQUIREMENT ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ (KW_BY ~ SatisfactionSubjectMember)? ~ RequirementBody
}

SatisfactionSubjectMember = { SatisfactionParameter }

SatisfactionParameter = { SatisfactionFeatureValue }

SatisfactionFeatureValue = { OwnedExpression }

ConcernUsage = {
    OccurrenceUsagePrefix ~ KW_CONCERN ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

CaseUsage = {
    OccurrenceUsagePrefix ~ KW_CASE ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

AnalysisCaseUsage = {
    OccurrenceUsagePrefix ~ KW_ANALYSIS ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

VerificationCaseUsage = {
    OccurrenceUsagePrefix ~ KW_VERIFICATION ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

UseCaseUsage = {
    OccurrenceUsagePrefix ~ KW_USE ~ KW_CASE ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

IncludeUseCaseUsage = {
    OccurrenceUsagePrefix ~ KW_INCLUDE ~ (
        KW_USE ~ KW_CASE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ CaseBody
}

ViewpointUsage = {
    OccurrenceUsagePrefix ~ KW_VIEWPOINT ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

BindingConnectorAsUsage = {
    UsagePrefix ~ (KW_BINDING ~ UsageDeclaration?)? ~
    KW_BIND ~ ConnectorEndMember ~ "=" ~ ConnectorEndMember ~ DefinitionBody
}

SuccessionAsUsage = {
    UsagePrefix ~ (KW_SUCCESSION ~ UsageDeclaration?)? ~
    KW_FIRST ~ ConnectorEndMember ~ KW_THEN ~ ConnectorEndMember ~ DefinitionBody
}

ExtendedUsage = {
    UnextendedUsagePrefix ~ UsageExtensionKeyword+ ~ UsageDeclaration? ~ UsageCompletion
}
