// =============================================================================
// FEATURES
// =============================================================================

// FeatureDeclaration matches xtext:
// Identification FeatureSpecializationPart? | FeatureSpecializationPart
// Note: FeatureSpecializationPart first to handle contextual keywords (redefines, etc.)
// When input starts with specialization syntax (:, :>, :>>, etc.), match anonymous feature.
// Otherwise, match Identification with optional specialization.
// FeatureRelationshipPart* is appended for chains, inverse of, featured by
FeatureDeclaration = {
    FeatureSpecializationPart ~ FeatureRelationshipPart*
    | Identification ~ FeatureSpecializationPart? ~ FeatureRelationshipPart*
}

// KerML Feature Relationship Parts (chains, inverse of, featured by)
// These follow the FeatureSpecializationPart in FeatureDeclaration
FeatureRelationshipPart = {
    ChainingPart
    | InvertingPart
    | TypeFeaturingPart
}

// chains <qualified-name> | chains <feature-chain>
ChainingPart = { KW_CHAINS ~ (OwnedFeatureChain | QualifiedName) }

// inverse of <feature>
InvertingPart = { KW_INVERSE ~ KW_OF ~ (OwnedFeatureChain | QualifiedName) }

// featured by <type> [, <type>]*
TypeFeaturingPart = { KW_FEATURED ~ KW_BY ~ QualifiedName ~ ("," ~ QualifiedName)* }

FeatureSpecializationPart = {
    FeatureSpecialization+ ~ (MultiplicityPart ~ FeatureSpecialization*)?
    | MultiplicityPart ~ FeatureSpecialization*
}

FeatureSpecialization = {
    Typings
    | Subsettings
    | References_
    | Crosses
    | Redefinitions
}

Typings = { TypedBy ~ ("," ~ FeatureTyping)* }

TypedBy = { DefinedByToken ~ FeatureTyping }

FeatureTyping = { OwnedFeatureTyping | ConjugatedPortTyping }

OwnedFeatureTyping = { FeatureType }

// OwnedFeatureChain first - longer match (a.b.c) vs QualifiedName (a or A::B)
FeatureType = { OwnedFeatureChain | QualifiedName }

ConjugatedPortTyping = { "~" ~ QualifiedName }

Subsettings = { Subsets ~ ("," ~ OwnedSubsetting)* }

Subsets = { SubsetsToken ~ OwnedSubsetting }

OwnedSubsetting = { OwnedFeatureChain | QualifiedName }

References_ = { ReferencesToken ~ OwnedReferenceSubsetting }

OwnedReferenceSubsetting = { OwnedFeatureChain | QualifiedName }

Crosses = { CrossesToken ~ OwnedCrossSubsetting }

OwnedCrossSubsetting = { OwnedFeatureChain | QualifiedName }

Redefinitions = { Redefines ~ ("," ~ OwnedRedefinition)* }

Redefines = { RedefinesToken ~ OwnedRedefinition }

OwnedRedefinition = { OwnedFeatureChain | QualifiedName }

// Feature chains
OwnedFeatureChain = { FeatureChain }

FeatureChain = { OwnedFeatureChaining ~ ("." ~ OwnedFeatureChaining)+ }

FeatureChainPrefix = { (OwnedFeatureChaining ~ ".")+ ~ OwnedFeatureChaining ~ "." }

OwnedFeatureChaining = { QualifiedName }

// Multiplicity
MultiplicityPart = {
    OwnedMultiplicity ~ MultiplicityProperties?
    | MultiplicityProperties
}

OwnedMultiplicity = { MultiplicityRange }

MultiplicityRange = { "[" ~ MultiplicityExpressionMember ~ "]" }

MultiplicityExpressionMember = { OwnedExpression }

// Value part
ValuePart = { FeatureValue }

FeatureValue = {
    ("=" | ":=" | (KW_DEFAULT ~ ("=" | ":=")?)) ~ OwnedExpression
}
