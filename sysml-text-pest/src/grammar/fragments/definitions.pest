// =============================================================================
// DEFINITIONS
// =============================================================================

DefinitionElement = {
    Package
    | LibraryPackage
    | AttributeDefinition
    | EnumerationDefinition
    | OccurrenceDefinition
    | ItemDefinition
    | MetadataDefinition
    | PartDefinition
    | ConnectionDefinition
    | FlowConnectionDefinition
    | InterfaceDefinition
    | AllocationDefinition
    | PortDefinition
    | ActionDefinition
    | CalculationDefinition
    | StateDefinition
    | ConstraintDefinition
    | RequirementDefinition
    | ConcernDefinition
    | CaseDefinition
    | AnalysisCaseDefinition
    | VerificationCaseDefinition
    | UseCaseDefinition
    | ViewDefinition
    | ViewpointDefinition
    | RenderingDefinition
    | ExtendedDefinition
    // KerML types (needed for standard library parsing)
    | ClassifierDefinition
    | DatatypeDefinition
    | ClassDefinition
    | StructDefinition
    | AssociationDefinition
    | AssociationStructDefinition
    | MultiplicityDefinition
    | FeatureDefinition
    // KerML behavior/function types (for standard library parsing)
    | BehaviorDefinition
    | FunctionDefinition
    | PredicateDefinition
    | InteractionDefinition
    | MetaclassDefinition
}

DefinitionPrefix = { BasicDefinitionPrefix? ~ DefinitionExtensionKeyword* }
BasicDefinitionPrefix = { Abstract | Variation }
DefinitionExtensionKeyword = { PrefixMetadataMember }

// Per KerML.xtext ClassifierDeclaration: ( isSufficient ?= 'all' )? Identification? SpecializationPart?
DefinitionDeclaration = { Sufficient? ~ Identification? ~ SubclassificationPart? ~ TypeRelationshipPart* }

// Type Relationship Parts (intersects, unions, differences, disjoints)
// Per KerML.xtext lines 341-363
TypeRelationshipPart = {
    DisjoiningPart
    | UnioningPart
    | IntersectingPart
    | DifferencingPart
}

// 'disjoint from' Type (',' Type)*
DisjoiningPart = { KW_DISJOINT ~ KW_FROM ~ Disjoining ~ ("," ~ Disjoining)* }

// 'unions' Type (',' Type)*
UnioningPart = { KW_UNIONS ~ Unioning ~ ("," ~ Unioning)* }

// 'intersects' Type (',' Type)*
IntersectingPart = { KW_INTERSECTS ~ Intersecting ~ ("," ~ Intersecting)* }

// 'differences' Type (',' Type)*
DifferencingPart = { KW_DIFFERENCES ~ Differencing ~ ("," ~ Differencing)* }

// Type references for relationship parts
Disjoining = { OwnedFeatureChain | QualifiedName }
Unioning = { OwnedFeatureChain | QualifiedName }
Intersecting = { OwnedFeatureChain | QualifiedName }
Differencing = { OwnedFeatureChain | QualifiedName }

DefinitionBody = { ";" | "{" ~ DefinitionBodyItem* ~ "}" }

DefinitionBodyItem = {
    Import
    | AliasMember
    | AnnotatingMember
    | RelationshipMember
    | DefinitionMember
    | VariantUsageMember
    // Actor/Stakeholder/Subject members (allowed in package bodies as extension)
    | ActorMember
    | StakeholderMember
    | SubjectMember
    | NonOccurrenceUsageMember
    // OccurrenceUsageMember can be preceded by 'then' (empty succession marker)
    | OccurrenceUsageMemberWithSuccession
}

// OccurrenceUsageMember with optional 'then' prefix for successions
// Pattern: [then [multiplicity]] [visibility] occurrence_usage
OccurrenceUsageMemberWithSuccession = {
    (KW_THEN ~ OwnedMultiplicity?)? ~ Visibility? ~ OccurrenceUsageElement
}

// Subclassification
SubclassificationPart = {
    SpecializesToken ~ OwnedSubclassification ~ ("," ~ OwnedSubclassification)*
}

OwnedSubclassification = { QualifiedName }

// Specific definitions
AttributeDefinition = {
    DefinitionPrefix ~ KW_ATTRIBUTE ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

EnumerationDefinition = {
    PrefixMetadata? ~ KW_ENUM ~ KW_DEF ~ DefinitionDeclaration ~ EnumerationBody
}

EnumerationBody = { ";" | "{" ~ EnumerationBodyItem* ~ "}" }

EnumerationBodyItem = {
    AnnotatingMember
    | EnumerationUsageMember
}

EnumerationUsageMember = { Visibility? ~ EnumeratedValue }

EnumeratedValue = { PrefixMetadata? ~ KW_ENUM? ~ UsageDeclaration? ~ UsageCompletion }

OccurrenceDefinition = {
    OccurrenceDefinitionPrefix ~ KW_OCCURRENCE ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

OccurrenceDefinitionPrefix = {
    BasicDefinitionPrefix? ~ Individual? ~ DefinitionExtensionKeyword*
}

ItemDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ITEM ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

MetadataDefinition = {
    Abstract? ~ PrefixMetadata? ~ KW_METADATA ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

PartDefinition = {
    OccurrenceDefinitionPrefix ~ KW_PART ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

PortDefinition = {
    DefinitionPrefix ~ KW_PORT ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ConnectionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONNECTION ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

FlowConnectionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_FLOW ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

InterfaceDefinition = {
    OccurrenceDefinitionPrefix ~ KW_INTERFACE ~ KW_DEF ~ DefinitionDeclaration ~ InterfaceBody
}

InterfaceBody = { ";" | "{" ~ InterfaceBodyItem* ~ "}" }

InterfaceBodyItem = { DefinitionBodyItem }

AllocationDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ALLOCATION ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ActionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ACTION ~ KW_DEF ~ DefinitionDeclaration ~ ActionBody
}

ActionBody = { ";" | "{" ~ ActionBodyItem* ~ "}" }

// ActionBodyItem: Items allowed inside action bodies
// The xtext grammar has complex patterns for succession handling:
// - (then)? StructureUsageMember
// - InitialNodeMember followed by TargetSuccessionMember*
// - (then)? (BehaviorUsageMember | ActionNodeMember) followed by TargetSuccessionMember*
ActionBodyItem = {
    DefinitionBodyItem
    | InitialNodeMember ~ TargetSuccessionMember*
    | ControlNodeMember
    // Behavior usages (including IncludeUseCaseUsage) with optional then prefix and succession chain
    | ActionBodyBehaviorMember
    // Standalone target succession (for else branches etc)
    | TargetSuccessionMember
}

// ActionBodyBehaviorMember: Behavior usage element with optional then prefix and succession chain
// Pattern: [then] (BehaviorUsageElement | ActionNode) [then target]*
ActionBodyBehaviorMember = {
    (KW_THEN ~ OwnedMultiplicity?)? ~ Visibility? ~
    (BehaviorUsageElement | ActionNode) ~
    TargetSuccessionMember*
}

InitialNodeMember = { Visibility? ~ KW_FIRST ~ QualifiedName ~ RelationshipBody }

ControlNodeMember = { Visibility? ~ ControlNode }

ActionNodeMember = { Visibility? ~ ActionNode }

StateDefinition = {
    OccurrenceDefinitionPrefix ~ KW_STATE ~ KW_DEF ~ DefinitionDeclaration ~ StateBody
}

StateBody = { ";" | KW_PARALLEL? ~ "{" ~ StateBodyItem* ~ "}" }

StateBodyItem = {
    // Entry/Do/Exit with optional transitions after - must come first!
    // Pattern: entry; then off;
    EntryActionMember ~ EntryTransitionMember*
    | DoActionMember
    | ExitActionMember
    | TransitionUsageMember
    | Import
    | AliasMember
    | AnnotatingMember
    | DefinitionMember
    | VariantUsageMember
    | NonOccurrenceUsageMember
    // Structure usages with optional 'then' prefix
    | (KW_THEN ~ OwnedMultiplicity?)? ~ Visibility? ~ StructureUsageElement
    // Behavior usages with optional accept/transitions
    | StateBodyBehaviorItem
}

// StateBodyBehaviorItem: Behavior usage followed by optional transitions
// Handles: accept SigSwitchOn then standBy;
StateBodyBehaviorItem = {
    (KW_THEN ~ OwnedMultiplicity?)? ~ Visibility? ~ BehaviorUsageElement ~ TargetTransitionMember*
}

// TargetTransitionMember: Transition after a behavior usage in state body
// Handles: then standBy; or accept trigger then target;
TargetTransitionMember = { Visibility? ~ TargetTransitionUsage }

// TargetTransitionUsage: A transition usage targeting a state
// Can have optional trigger, guard, effect before 'then target'
TargetTransitionUsage = {
    (
        KW_TRANSITION ~ TriggerActionMember? ~ GuardExpressionMember? ~ EffectBehaviorMember?
        | TriggerActionMember ~ GuardExpressionMember? ~ EffectBehaviorMember?
        | GuardExpressionMember ~ EffectBehaviorMember?
    )? ~
    KW_THEN ~ TransitionSuccessionMember ~ ActionBody
}

EntryActionMember = { Visibility? ~ KW_ENTRY ~ StateActionUsage }
DoActionMember = { Visibility? ~ KW_DO ~ StateActionUsage }
ExitActionMember = { Visibility? ~ KW_EXIT ~ StateActionUsage }

// EntryTransitionMember: Transition after entry action
// Handles: entry; then off;
EntryTransitionMember = { Visibility? ~ (GuardedTargetSuccession | KW_THEN ~ TransitionSuccession) ~ ";" }

// StateActionUsage supports:
// - Empty: ";"
// - PerformedActionUsage: (OwnedReferenceSubsetting | "action" UsageDeclaration?) ValuePart? ActionBody
StateActionUsage = {
    ";"
    | PerformedActionUsageDeclaration ~ ValuePart? ~ ActionBody
}

// KW_ACTION first - if we see 'action' keyword, use that branch.
// Otherwise fall back to OwnedReferenceSubsetting for patterns like `:>> someAction`
PerformedActionUsageDeclaration = {
    KW_ACTION ~ UsageDeclaration?
    | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
}

TransitionUsageMember = { Visibility? ~ TransitionUsage }

CalculationDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CALC ~ KW_DEF ~ DefinitionDeclaration ~ CalculationBody
}

CalculationBody = { ";" | "{" ~ CalculationBodyItem* ~ ResultExpressionMember? ~ "}" }

CalculationBodyItem = {
    ActionBodyItem
    | ReturnParameterMember
}

ReturnParameterMember = { Visibility? ~ KW_RETURN ~ UsageElement }

ResultExpressionMember = { Visibility? ~ OwnedExpression }

ConstraintDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONSTRAINT ~ KW_DEF ~ DefinitionDeclaration ~ CalculationBody
}

RequirementDefinition = {
    OccurrenceDefinitionPrefix ~ KW_REQUIREMENT ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

RequirementBody = { ";" | "{" ~ RequirementBodyItem* ~ "}" }

RequirementBodyItem = {
    DefinitionBodyItem
    | SubjectMember
    | RequirementConstraintMember
    | FramedConcernMember
    | ActorMember
    | StakeholderMember
}

// FramedConcernMember: 'frame' concern_usage
// Pattern: frame concern ConcernName;
FramedConcernMember = { Visibility? ~ KW_FRAME ~ FramedConcernUsage }

// FramedConcernUsage supports:
// 1. Reference subsetting: :>> concernRef { ... }
// 2. With 'concern' keyword: concern [name] [body]
FramedConcernUsage = {
    OwnedReferenceSubsetting ~ FeatureSpecialization* ~ RequirementBody
    | (PrefixMetadata* ~ KW_CONCERN | PrefixMetadata+) ~
        UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

SubjectMember = { Visibility? ~ KW_SUBJECT ~ SubjectUsage }
SubjectUsage = { UsageDeclaration? ~ UsageCompletion }

RequirementConstraintMember = {
    Visibility? ~ RequirementConstraintKind ~ RequirementConstraintUsage
}
// Note: RequirementConstraintKind is generated from xtext enums
// RequirementConstraintUsage supports:
// 1. Reference subsetting: :>> constraintRef { ... }
// 2. With 'constraint' keyword: constraint [name] { ... }
// 3. Inline expression: { expr }
RequirementConstraintUsage = {
    OwnedReferenceSubsetting ~ FeatureSpecialization* ~ CalculationBody
    | (PrefixMetadata* ~ KW_CONSTRAINT | PrefixMetadata+) ~
        UsageDeclaration? ~ ValuePart? ~ CalculationBody
    | UsageDeclaration? ~ CalculationBody
}

ActorMember = { Visibility? ~ KW_ACTOR ~ ActorUsage }
ActorUsage = { UsageDeclaration? ~ UsageCompletion }

StakeholderMember = { Visibility? ~ KW_STAKEHOLDER ~ StakeholderUsage }
StakeholderUsage = { UsageDeclaration? ~ UsageCompletion }

ConcernDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONCERN ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

CaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CASE ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

CaseBody = { ";" | "{" ~ CaseBodyItem* ~ ResultExpressionMember? ~ "}" }

CaseBodyItem = {
    CalculationBodyItem
    | SubjectMember
    | ActorMember
    | ObjectiveMember
}

ObjectiveMember = { Visibility? ~ KW_OBJECTIVE ~ ObjectiveRequirementUsage }
ObjectiveRequirementUsage = { UsageDeclaration? ~ RequirementBody }

AnalysisCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ANALYSIS ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

VerificationCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VERIFICATION ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

UseCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_USE ~ KW_CASE ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

ViewDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VIEW ~ KW_DEF ~ DefinitionDeclaration ~ ViewBody
}

ViewBody = { ";" | "{" ~ ViewBodyItem* ~ "}" }

ViewBodyItem = {
    DefinitionBodyItem
    | ElementFilterMember
    | ViewRenderingMember
}

ViewRenderingMember = { Visibility? ~ KW_RENDER ~ ViewRenderingUsage }
ViewRenderingUsage = {
    OwnedReferenceSubsetting ~ FeatureSpecialization* ~ UsageBody
    | UsageDeclaration? ~ UsageCompletion
}

ViewpointDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VIEWPOINT ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

RenderingDefinition = {
    OccurrenceDefinitionPrefix ~ KW_RENDERING ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ExtendedDefinition = {
    BasicDefinitionPrefix? ~ DefinitionExtensionKeyword+ ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

// =============================================================================
// KERML TYPES (for standard library parsing)
// =============================================================================

// KerML Classifier: [abstract] classifier Name [:> Parent] { ... } | ;
ClassifierDefinition = {
    DefinitionPrefix ~ KW_CLASSIFIER ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML DataType: [abstract] datatype Name [:> Parent] { ... } | ;
DatatypeDefinition = {
    DefinitionPrefix ~ KW_DATATYPE ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Class: [abstract] class Name [:> Parent] { ... } | ;
ClassDefinition = {
    DefinitionPrefix ~ KW_CLASS ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Structure: [abstract] struct Name [:> Parent] { ... } | ;
StructDefinition = {
    DefinitionPrefix ~ KW_STRUCT ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Association: [abstract] assoc Name [:> Parent] { ... } | ;
AssociationDefinition = {
    DefinitionPrefix ~ KW_ASSOC ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML AssociationStructure: [abstract] assoc struct Name [:> Parent] { ... } | ;
AssociationStructDefinition = {
    DefinitionPrefix ~ KW_ASSOC ~ KW_STRUCT ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Multiplicity: multiplicity Name [bounds] { ... } | ;
MultiplicityDefinition = {
    KW_MULTIPLICITY ~ Identification? ~ OwnedMultiplicity? ~ DefinitionBody
}

// KerML Feature: [modifiers] feature [name] [:> Parent] [= value] { ... } | ;
// Per KerML.xtext (lines 539-547):
//   Feature: (FeaturePrefix ('feature' | PrefixMetadataMember) FeatureDeclaration?
//            | (EndFeaturePrefix | BasicFeaturePrefix) FeatureDeclaration) ValuePart? TypeBody
// Where FeaturePrefix = (EndFeaturePrefix OwnedCrossingFeatureMember? | BasicFeaturePrefix) PrefixMetadataMember*
//
// Pattern 1: prefix feature decl? valuePart? body  (simple feature)
// Pattern 2: end crossing? feature decl? valuePart? body  (end feature with crossing)
// Pattern 3: end decl valuePart? body  (end feature without keyword)
// Pattern 4: prefix decl valuePart? body  (simple feature without keyword)
FeatureDefinition = {
    // Pattern 1 & 2: with 'feature' keyword
    (EndUsagePrefix | RefPrefix) ~ KW_FEATURE ~ UsageDeclaration? ~ UsageCompletion
    // Pattern 3 & 4 without 'feature' keyword are handled by DefaultReferenceUsage
}

// KerML Behavior: [abstract] behavior Name [:> Parent] { ... } | ;
BehaviorDefinition = {
    DefinitionPrefix ~ KW_BEHAVIOR ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Function: [abstract] function Name [:> Parent] { ... } | ;
// Uses FunctionBody which supports return and result expression
FunctionDefinition = {
    DefinitionPrefix ~ KW_FUNCTION ~ DefinitionDeclaration ~ FunctionBody
}

// KerML Predicate: [abstract] predicate Name [:> Parent] { ... } | ;
PredicateDefinition = {
    DefinitionPrefix ~ KW_PREDICATE ~ DefinitionDeclaration ~ FunctionBody
}

// KerML Interaction: [abstract] interaction Name [:> Parent] { ... } | ;
InteractionDefinition = {
    DefinitionPrefix ~ KW_INTERACTION ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Metaclass: [abstract] metaclass Name [:> Parent] { ... } | ;
MetaclassDefinition = {
    DefinitionPrefix ~ KW_METACLASS ~ DefinitionDeclaration ~ DefinitionBody
}

// FunctionBody: Function and predicate body with return and result expression
FunctionBody = { ";" | "{" ~ FunctionBodyItem* ~ ResultExpressionMember? ~ "}" }

FunctionBodyItem = {
    DefinitionBodyItem
    | ReturnParameterMember
}
