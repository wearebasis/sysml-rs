// SysML v2 Grammar for pest
// Based on SySide Langium grammar (4244 lines)
// This is a PEG grammar that closely follows the official specification
//
// This grammar is generated by build.rs, combining manual fragments with
// auto-generated rules for keywords, operators, and enums.

// =============================================================================
// WHITESPACE AND COMMENTS
// =============================================================================

WHITESPACE = _{ " " | "\t" | NEWLINE }
NEWLINE = _{ "\r\n" | "\n" | "\r" }

// Single-line comment: // ...
SL_COMMENT = _{ "//" ~ !("*") ~ (!NEWLINE ~ ANY)* }

// Multi-line comment: /* ... */
ML_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Single-line note: //* ... (hidden)
SL_NOTE = _{ "//*" ~ (!NEWLINE ~ ANY)* }

// Multi-line note: //* ... */ (hidden)
ML_NOTE = _{ "//*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Note: ML_COMMENT is intentionally NOT in the implicit COMMENT rule.
// Multi-line comments /* ... */ should only be consumed by explicit rules:
// Comment, Documentation, TextualRepresentation (via REGULAR_COMMENT_BODY).
// This prevents documentation comments from being silently discarded.
COMMENT = _{ SL_COMMENT }

// =============================================================================
// TERMINALS
// =============================================================================

// Reserved literals that cannot be used as identifiers
//
// SysML uses CONTEXTUAL keywords (like xtext), not RESERVED keywords (like C/Java).
// The xtext grammar defines: ID = ('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
// with NO keyword exclusion - keywords are handled by grammar context via PEG ordered choice.
//
// Only true literals that can never be identifiers are blocked here.
// All other "keywords" (action, part, state, etc.) work as identifiers in appropriate contexts.
RESERVED = @{
    ("true" | "false" | "null") ~ !(ASCII_ALPHANUMERIC | "_")
}

// Identifiers - only block true literals
// Keywords are contextual and handled by grammar rules using KW_* with PEG ordered choice
ID = @{ !RESERVED ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Unrestricted name: 'name with spaces'
UNRESTRICTED_NAME = @{ "'" ~ (ESCAPE_SEQUENCE | (!("'" | "\\") ~ ANY))* ~ "'" }

// String literals
STRING_VALUE = @{ "\"" ~ (ESCAPE_SEQUENCE | (!("\"" | "\\") ~ ANY))* ~ "\"" }

// Escape sequences
ESCAPE_SEQUENCE = _{ "\\" ~ ("'" | "\"" | "b" | "f" | "t" | "n" | "r" | "\\") }

// Numbers
DECIMAL = @{ ASCII_DIGIT+ }
FRACTION = @{ "." ~ DECIMAL }
FLOAT = @{ DECIMAL ~ FRACTION? | FRACTION }
EXPONENT = @{ ("e" | "E") ~ ("-" | "+")? ~ DECIMAL }
NUMBER = @{ FLOAT ~ EXPONENT? }

// Regular comment body for textual annotations
REGULAR_COMMENT_BODY = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// =============================================================================
// NAMES AND REFERENCES
// =============================================================================

Name = { ID | UNRESTRICTED_NAME }

// Short name: <name>
ShortName = { "<" ~ Name ~ ">" }

// Regular name: just the name
RegularName = { Name }

// Identification: <shortName> name | name | <shortName>
Identification = { ShortName ~ RegularName? | RegularName }

// Qualified reference chain: A::B::C
QualifiedName = { Name ~ ("::" ~ Name)* }

// =============================================================================
// KEYWORDS (Generated from SysML/KerML xtext files)
// Keywords use word boundary checking to prevent partial matching.
// =============================================================================

KW_ABOUT = @{ "about" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ABSTRACT = @{ "abstract" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ACCEPT = @{ "accept" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ACTION = @{ "action" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ACTOR = @{ "actor" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_AFTER = @{ "after" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ALIAS = @{ "alias" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ALL = @{ "all" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ALLOCATE = @{ "allocate" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ALLOCATION = @{ "allocation" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ANALYSIS = @{ "analysis" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_AND = @{ "and" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_AS = @{ "as" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ASSERT = @{ "assert" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ASSIGN = @{ "assign" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ASSOC = @{ "assoc" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ASSUME = @{ "assume" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_AT = @{ "at" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ATTRIBUTE = @{ "attribute" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_BEHAVIOR = @{ "behavior" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_BIND = @{ "bind" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_BINDING = @{ "binding" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_BOOL = @{ "bool" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_BY = @{ "by" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CALC = @{ "calc" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CASE = @{ "case" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CHAINS = @{ "chains" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CLASS = @{ "class" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CLASSIFIER = @{ "classifier" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_COMMENT = @{ "comment" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_COMPOSITE = @{ "composite" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONCERN = @{ "concern" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONJUGATE = @{ "conjugate" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONJUGATES = @{ "conjugates" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONJUGATION = @{ "conjugation" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONNECT = @{ "connect" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONNECTION = @{ "connection" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONNECTOR = @{ "connector" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONST = @{ "const" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONSTANT = @{ "constant" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CONSTRAINT = @{ "constraint" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_CROSSES = @{ "crosses" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DATATYPE = @{ "datatype" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DECIDE = @{ "decide" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DEF = @{ "def" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DEFAULT = @{ "default" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DEFINED = @{ "defined" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DEPENDENCY = @{ "dependency" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DERIVED = @{ "derived" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DIFFERENCES = @{ "differences" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DISJOINING = @{ "disjoining" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DISJOINT = @{ "disjoint" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DO = @{ "do" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_DOC = @{ "doc" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ELSE = @{ "else" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_END = @{ "end" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ENTRY = @{ "entry" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ENUM = @{ "enum" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_EVENT = @{ "event" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_EXHIBIT = @{ "exhibit" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_EXIT = @{ "exit" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_EXPOSE = @{ "expose" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_EXPR = @{ "expr" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FALSE = @{ "false" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FEATURE = @{ "feature" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FEATURED = @{ "featured" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FEATURING = @{ "featuring" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FILTER = @{ "filter" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FIRST = @{ "first" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FLOW = @{ "flow" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FOR = @{ "for" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FORK = @{ "fork" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FRAME = @{ "frame" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FROM = @{ "from" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_FUNCTION = @{ "function" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_HASTYPE = @{ "hastype" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_IF = @{ "if" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_IMPLIES = @{ "implies" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_IMPORT = @{ "import" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_IN = @{ "in" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INCLUDE = @{ "include" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INDIVIDUAL = @{ "individual" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INOUT = @{ "inout" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INTERACTION = @{ "interaction" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INTERFACE = @{ "interface" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INTERSECTS = @{ "intersects" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INV = @{ "inv" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INVERSE = @{ "inverse" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_INVERTING = @{ "inverting" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ISTYPE = @{ "istype" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ITEM = @{ "item" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_JOIN = @{ "join" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_LANGUAGE = @{ "language" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_LIBRARY = @{ "library" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_LOCALE = @{ "locale" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_LOOP = @{ "loop" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_MEMBER = @{ "member" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_MERGE = @{ "merge" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_MESSAGE = @{ "message" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_META = @{ "meta" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_METACLASS = @{ "metaclass" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_METADATA = @{ "metadata" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_MULTIPLICITY = @{ "multiplicity" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_NAMESPACE = @{ "namespace" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_NEW = @{ "new" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_NONUNIQUE = @{ "nonunique" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_NOT = @{ "not" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_NULL = @{ "null" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_OBJECTIVE = @{ "objective" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_OCCURRENCE = @{ "occurrence" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_OF = @{ "of" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_OR = @{ "or" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_ORDERED = @{ "ordered" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_OUT = @{ "out" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PACKAGE = @{ "package" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PARALLEL = @{ "parallel" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PART = @{ "part" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PERFORM = @{ "perform" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PORT = @{ "port" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PORTION = @{ "portion" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PREDICATE = @{ "predicate" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PRIVATE = @{ "private" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PROTECTED = @{ "protected" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_PUBLIC = @{ "public" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_READONLY = @{ "readonly" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_REDEFINES = @{ "redefines" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_REDEFINITION = @{ "redefinition" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_REF = @{ "ref" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_REFERENCES = @{ "references" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_RENDER = @{ "render" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_RENDERING = @{ "rendering" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_REP = @{ "rep" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_REQUIRE = @{ "require" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_REQUIREMENT = @{ "requirement" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_RETURN = @{ "return" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SATISFY = @{ "satisfy" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SEND = @{ "send" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SNAPSHOT = @{ "snapshot" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SPECIALIZATION = @{ "specialization" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SPECIALIZES = @{ "specializes" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_STAKEHOLDER = @{ "stakeholder" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_STANDARD = @{ "standard" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_STATE = @{ "state" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_STEP = @{ "step" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_STRUCT = @{ "struct" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SUBCLASSIFIER = @{ "subclassifier" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SUBJECT = @{ "subject" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SUBSET = @{ "subset" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SUBSETS = @{ "subsets" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SUBTYPE = @{ "subtype" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_SUCCESSION = @{ "succession" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_TERMINATE = @{ "terminate" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_THEN = @{ "then" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_TIMESLICE = @{ "timeslice" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_TO = @{ "to" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_TRANSITION = @{ "transition" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_TRUE = @{ "true" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_TYPE = @{ "type" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_TYPED = @{ "typed" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_TYPING = @{ "typing" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_UNIONS = @{ "unions" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_UNTIL = @{ "until" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_USE = @{ "use" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_VAR = @{ "var" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_VARIANT = @{ "variant" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_VARIATION = @{ "variation" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_VERIFICATION = @{ "verification" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_VERIFY = @{ "verify" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_VIA = @{ "via" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_VIEW = @{ "view" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_VIEWPOINT = @{ "viewpoint" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_WHEN = @{ "when" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_WHILE = @{ "while" ~ !(ASCII_ALPHANUMERIC | "_") }
KW_XOR = @{ "xor" ~ !(ASCII_ALPHANUMERIC | "_") }

// =============================================================================
// OPERATORS (Generated from KerMLExpressions.xtext)
// =============================================================================

ConditionalOperator = { KW_IF }
NullCoalescingOperator = { "??" }
ImpliesOperator = { KW_IMPLIES }
OrOperator = { "|" }
ConditionalOrOperator = { KW_OR }
XorOperator = { KW_XOR }
AndOperator = { "&" }
ConditionalAndOperator = { KW_AND }
EqualityOperator = { "===" | "!==" | "==" | "!=" }
ClassificationTestOperator = { KW_HASTYPE | KW_ISTYPE | "@" }
MetaClassificationTestOperator = { "@@" }
CastOperator = { KW_AS }
MetaCastOperator = { KW_META }
RelationalOperator = { "<=" | ">=" | "<" | ">" }
AdditiveOperator = { "+" | "-" }
MultiplicativeOperator = { "*" | "/" | "%" }
ExponentiationOperator = { "**" | "^" }
UnaryOperator = { KW_NOT | "+" | "-" | "~" }

// =============================================================================
// ENUMS (Generated from SysML.xtext)
// =============================================================================

FeatureDirectionKind = { KW_INOUT | KW_OUT | KW_IN }
PortionKind = { KW_TIMESLICE | KW_SNAPSHOT }
RequirementConstraintKind = { KW_REQUIRE | KW_ASSUME | KW_VERIFY | KW_FRAME }
TransitionFeatureKind = { KW_ACCEPT | KW_DO | KW_IF }
VisibilityKind = { KW_PROTECTED | KW_PRIVATE | KW_EXPOSE | KW_PUBLIC }

// =============================================================================
// TOKENS (Composite tokens that reference keywords)
// =============================================================================

// Specialization tokens
SpecializesToken = { ":>" | KW_SPECIALIZES }
SubsetsToken = { ":>" | KW_SUBSETS }
ReferencesToken = { "::>" | KW_REFERENCES }
CrossesToken = { "=>" | KW_CROSSES }
RedefinesToken = { ":>>" | KW_REDEFINES }
TypedByToken = { ":" | (KW_TYPED ~ KW_BY) }
DefinedByToken = { ":" | (KW_DEFINED ~ KW_BY) }
ConjugatesToken = { "~" | KW_CONJUGATES }

// Import kind
ImportKind = { "::*::**" | "::**" | "::*" }

// =============================================================================
// COMMON FRAGMENTS
// =============================================================================

Abstract = { KW_ABSTRACT }
Visibility = { VisibilityKind }
Readonly = { KW_READONLY }
Derived = { KW_DERIVED }
End = { KW_END }
Sufficient = { KW_ALL }
Standard = { KW_STANDARD }
ImportAll = { KW_ALL }
Variation = { KW_VARIATION }
Individual = { KW_INDIVIDUAL }

// KerML feature modifiers (for standard library parsing)
// These appear in BasicFeaturePrefix: composite | portion, var | const
Composite = { KW_COMPOSITE }
FeaturePortion = { KW_PORTION }
Variable = { KW_VAR }
Constant = { KW_CONST }

MultiplicityProperties = {
    (KW_ORDERED ~ KW_NONUNIQUE?)
    | (KW_NONUNIQUE ~ KW_ORDERED?)
}

// =============================================================================
// ENTRY POINT
// =============================================================================

// Main entry point - a file can contain package body elements
File = { SOI ~ PackageBodyElement* ~ EOI }

// Alternative entry point for testing
Model = { SOI ~ PackageBodyElement* ~ EOI }

// =============================================================================
// PACKAGES
// =============================================================================

Package = {
    PrefixMetadata? ~ KW_PACKAGE ~ Identification? ~ PackageBody
}

LibraryPackage = {
    Standard? ~ KW_LIBRARY ~ PrefixMetadata? ~ KW_PACKAGE ~ Identification? ~ PackageBody
}

PackageBody = { ";" | "{" ~ PackageBodyElement* ~ "}" }

PackageBodyElement = {
    Import
    | AliasMember
    | ElementFilterMember
    | AnnotatingMember
    // Actor/Subject/Stakeholder members (allowed in package bodies as extension)
    | ActorMember
    | StakeholderMember
    | SubjectMember
    | UsageMember
    | DefinitionMember
    | RelationshipMember
}

// =============================================================================
// IMPORTS
// =============================================================================

Import = {
    ImportPrefix ~ ImportedReference ~ FilterPackage? ~ RelationshipBody
}

ImportPrefix = { Visibility? ~ KW_IMPORT ~ ImportAll? }

// ImportedReference: QualifiedName with optional ::* or ::** suffix
// IMPORTANT: Try ::** BEFORE ::* since ::* is a prefix of ::**
ImportedReference = {
    QualifiedName ~ (ImportRecursiveMarker | ImportNamespaceMarker)?
}

ImportNamespaceMarker = { "::*" }
ImportRecursiveMarker = { "::**" }

FilterPackage = { FilterPackageMember+ }

FilterPackageMember = { "[" ~ OwnedExpression ~ "]" }

// =============================================================================
// MEMBERS
// =============================================================================

AliasMember = {
    Visibility? ~ KW_ALIAS ~ Identification? ~ KW_FOR ~ QualifiedName ~ RelationshipBody
}

ElementFilterMember = {
    Visibility? ~ KW_FILTER ~ OwnedExpression ~ ";"
}

AnnotatingMember = { Visibility? ~ AnnotatingElement }

UsageMember = { Visibility? ~ UsageElement }

DefinitionMember = { Visibility? ~ DefinitionElement }

RelationshipMember = { Visibility? ~ Dependency }

VariantUsageMember = { Visibility? ~ KW_VARIANT ~ VariantUsageElement }

NonOccurrenceUsageMember = { Visibility? ~ NonOccurrenceUsageElement }

OccurrenceUsageMember = { Visibility? ~ OccurrenceUsageElement }

// =============================================================================
// DEFINITIONS
// =============================================================================

DefinitionElement = {
    Package
    | LibraryPackage
    | AttributeDefinition
    | EnumerationDefinition
    | OccurrenceDefinition
    | ItemDefinition
    | MetadataDefinition
    | PartDefinition
    | ConnectionDefinition
    | FlowConnectionDefinition
    | InterfaceDefinition
    | AllocationDefinition
    | PortDefinition
    | ActionDefinition
    | CalculationDefinition
    | StateDefinition
    | ConstraintDefinition
    | RequirementDefinition
    | ConcernDefinition
    | CaseDefinition
    | AnalysisCaseDefinition
    | VerificationCaseDefinition
    | UseCaseDefinition
    | ViewDefinition
    | ViewpointDefinition
    | RenderingDefinition
    | ExtendedDefinition
    // KerML types (needed for standard library parsing)
    | ClassifierDefinition
    | DatatypeDefinition
    | ClassDefinition
    | StructDefinition
    | AssociationDefinition
    | AssociationStructDefinition
    | MultiplicityDefinition
    | FeatureDefinition
    // KerML behavior/function types (for standard library parsing)
    | BehaviorDefinition
    | FunctionDefinition
    | PredicateDefinition
    | InteractionDefinition
    | MetaclassDefinition
}

DefinitionPrefix = { BasicDefinitionPrefix? ~ DefinitionExtensionKeyword* }
BasicDefinitionPrefix = { Abstract | Variation }
DefinitionExtensionKeyword = { PrefixMetadataMember }

DefinitionDeclaration = { Identification? ~ SubclassificationPart? }

DefinitionBody = { ";" | "{" ~ DefinitionBodyItem* ~ "}" }

DefinitionBodyItem = {
    Import
    | AliasMember
    | AnnotatingMember
    | RelationshipMember
    | DefinitionMember
    | VariantUsageMember
    // Actor/Stakeholder/Subject members (allowed in package bodies as extension)
    | ActorMember
    | StakeholderMember
    | SubjectMember
    | NonOccurrenceUsageMember
    // OccurrenceUsageMember can be preceded by 'then' (empty succession marker)
    | OccurrenceUsageMemberWithSuccession
}

// OccurrenceUsageMember with optional 'then' prefix for successions
// Pattern: [then [multiplicity]] [visibility] occurrence_usage
OccurrenceUsageMemberWithSuccession = {
    (KW_THEN ~ OwnedMultiplicity?)? ~ Visibility? ~ OccurrenceUsageElement
}

// Subclassification
SubclassificationPart = {
    SpecializesToken ~ OwnedSubclassification ~ ("," ~ OwnedSubclassification)*
}

OwnedSubclassification = { QualifiedName }

// Specific definitions
AttributeDefinition = {
    DefinitionPrefix ~ KW_ATTRIBUTE ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

EnumerationDefinition = {
    PrefixMetadata? ~ KW_ENUM ~ KW_DEF ~ DefinitionDeclaration ~ EnumerationBody
}

EnumerationBody = { ";" | "{" ~ EnumerationBodyItem* ~ "}" }

EnumerationBodyItem = {
    AnnotatingMember
    | EnumerationUsageMember
}

EnumerationUsageMember = { Visibility? ~ EnumeratedValue }

EnumeratedValue = { PrefixMetadata? ~ KW_ENUM? ~ UsageDeclaration? ~ UsageCompletion }

OccurrenceDefinition = {
    OccurrenceDefinitionPrefix ~ KW_OCCURRENCE ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

OccurrenceDefinitionPrefix = {
    BasicDefinitionPrefix? ~ Individual? ~ DefinitionExtensionKeyword*
}

ItemDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ITEM ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

MetadataDefinition = {
    Abstract? ~ PrefixMetadata? ~ KW_METADATA ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

PartDefinition = {
    OccurrenceDefinitionPrefix ~ KW_PART ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

PortDefinition = {
    DefinitionPrefix ~ KW_PORT ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ConnectionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONNECTION ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

FlowConnectionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_FLOW ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

InterfaceDefinition = {
    OccurrenceDefinitionPrefix ~ KW_INTERFACE ~ KW_DEF ~ DefinitionDeclaration ~ InterfaceBody
}

InterfaceBody = { ";" | "{" ~ InterfaceBodyItem* ~ "}" }

InterfaceBodyItem = { DefinitionBodyItem }

AllocationDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ALLOCATION ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ActionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ACTION ~ KW_DEF ~ DefinitionDeclaration ~ ActionBody
}

ActionBody = { ";" | "{" ~ ActionBodyItem* ~ "}" }

// ActionBodyItem: Items allowed inside action bodies
// The xtext grammar has complex patterns for succession handling:
// - (then)? StructureUsageMember
// - InitialNodeMember followed by TargetSuccessionMember*
// - (then)? (BehaviorUsageMember | ActionNodeMember) followed by TargetSuccessionMember*
ActionBodyItem = {
    DefinitionBodyItem
    | InitialNodeMember ~ TargetSuccessionMember*
    | ControlNodeMember
    // Behavior usages (including IncludeUseCaseUsage) with optional then prefix and succession chain
    | ActionBodyBehaviorMember
    // Standalone target succession (for else branches etc)
    | TargetSuccessionMember
}

// ActionBodyBehaviorMember: Behavior usage element with optional then prefix and succession chain
// Pattern: [then] (BehaviorUsageElement | ActionNode) [then target]*
ActionBodyBehaviorMember = {
    (KW_THEN ~ OwnedMultiplicity?)? ~ Visibility? ~
    (BehaviorUsageElement | ActionNode) ~
    TargetSuccessionMember*
}

InitialNodeMember = { Visibility? ~ KW_FIRST ~ QualifiedName ~ RelationshipBody }

ControlNodeMember = { Visibility? ~ ControlNode }

ActionNodeMember = { Visibility? ~ ActionNode }

StateDefinition = {
    OccurrenceDefinitionPrefix ~ KW_STATE ~ KW_DEF ~ DefinitionDeclaration ~ StateBody
}

StateBody = { ";" | KW_PARALLEL? ~ "{" ~ StateBodyItem* ~ "}" }

StateBodyItem = {
    // Entry/Do/Exit with optional transitions after - must come first!
    // Pattern: entry; then off;
    EntryActionMember ~ EntryTransitionMember*
    | DoActionMember
    | ExitActionMember
    | TransitionUsageMember
    | Import
    | AliasMember
    | AnnotatingMember
    | DefinitionMember
    | VariantUsageMember
    | NonOccurrenceUsageMember
    // Structure usages with optional 'then' prefix
    | (KW_THEN ~ OwnedMultiplicity?)? ~ Visibility? ~ StructureUsageElement
    // Behavior usages with optional accept/transitions
    | StateBodyBehaviorItem
}

// StateBodyBehaviorItem: Behavior usage followed by optional transitions
// Handles: accept SigSwitchOn then standBy;
StateBodyBehaviorItem = {
    (KW_THEN ~ OwnedMultiplicity?)? ~ Visibility? ~ BehaviorUsageElement ~ TargetTransitionMember*
}

// TargetTransitionMember: Transition after a behavior usage in state body
// Handles: then standBy; or accept trigger then target;
TargetTransitionMember = { Visibility? ~ TargetTransitionUsage }

// TargetTransitionUsage: A transition usage targeting a state
// Can have optional trigger, guard, effect before 'then target'
TargetTransitionUsage = {
    (
        KW_TRANSITION ~ TriggerActionMember? ~ GuardExpressionMember? ~ EffectBehaviorMember?
        | TriggerActionMember ~ GuardExpressionMember? ~ EffectBehaviorMember?
        | GuardExpressionMember ~ EffectBehaviorMember?
    )? ~
    KW_THEN ~ TransitionSuccessionMember ~ ActionBody
}

EntryActionMember = { Visibility? ~ KW_ENTRY ~ StateActionUsage }
DoActionMember = { Visibility? ~ KW_DO ~ StateActionUsage }
ExitActionMember = { Visibility? ~ KW_EXIT ~ StateActionUsage }

// EntryTransitionMember: Transition after entry action
// Handles: entry; then off;
EntryTransitionMember = { Visibility? ~ (GuardedTargetSuccession | KW_THEN ~ TransitionSuccession) ~ ";" }

// StateActionUsage supports:
// - Empty: ";"
// - PerformedActionUsage: (OwnedReferenceSubsetting | "action" UsageDeclaration?) ValuePart? ActionBody
StateActionUsage = {
    ";"
    | PerformedActionUsageDeclaration ~ ValuePart? ~ ActionBody
}

// KW_ACTION first - if we see 'action' keyword, use that branch.
// Otherwise fall back to OwnedReferenceSubsetting for patterns like `:>> someAction`
PerformedActionUsageDeclaration = {
    KW_ACTION ~ UsageDeclaration?
    | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
}

TransitionUsageMember = { Visibility? ~ TransitionUsage }

CalculationDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CALC ~ KW_DEF ~ DefinitionDeclaration ~ CalculationBody
}

CalculationBody = { ";" | "{" ~ CalculationBodyItem* ~ ResultExpressionMember? ~ "}" }

CalculationBodyItem = {
    ActionBodyItem
    | ReturnParameterMember
}

ReturnParameterMember = { Visibility? ~ KW_RETURN ~ UsageElement }

ResultExpressionMember = { Visibility? ~ OwnedExpression }

ConstraintDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONSTRAINT ~ KW_DEF ~ DefinitionDeclaration ~ CalculationBody
}

RequirementDefinition = {
    OccurrenceDefinitionPrefix ~ KW_REQUIREMENT ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

RequirementBody = { ";" | "{" ~ RequirementBodyItem* ~ "}" }

RequirementBodyItem = {
    DefinitionBodyItem
    | SubjectMember
    | RequirementConstraintMember
    | FramedConcernMember
    | ActorMember
    | StakeholderMember
}

// FramedConcernMember: 'frame' concern_usage
// Pattern: frame concern ConcernName;
FramedConcernMember = { Visibility? ~ KW_FRAME ~ FramedConcernUsage }

// FramedConcernUsage supports:
// 1. Reference subsetting: :>> concernRef { ... }
// 2. With 'concern' keyword: concern [name] [body]
FramedConcernUsage = {
    OwnedReferenceSubsetting ~ FeatureSpecialization* ~ RequirementBody
    | (PrefixMetadata* ~ KW_CONCERN | PrefixMetadata+) ~
        UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

SubjectMember = { Visibility? ~ KW_SUBJECT ~ SubjectUsage }
SubjectUsage = { UsageDeclaration? ~ UsageCompletion }

RequirementConstraintMember = {
    Visibility? ~ RequirementConstraintKind ~ RequirementConstraintUsage
}
// Note: RequirementConstraintKind is generated from xtext enums
// RequirementConstraintUsage supports:
// 1. Reference subsetting: :>> constraintRef { ... }
// 2. With 'constraint' keyword: constraint [name] { ... }
// 3. Inline expression: { expr }
RequirementConstraintUsage = {
    OwnedReferenceSubsetting ~ FeatureSpecialization* ~ CalculationBody
    | (PrefixMetadata* ~ KW_CONSTRAINT | PrefixMetadata+) ~
        UsageDeclaration? ~ ValuePart? ~ CalculationBody
    | UsageDeclaration? ~ CalculationBody
}

ActorMember = { Visibility? ~ KW_ACTOR ~ ActorUsage }
ActorUsage = { UsageDeclaration? ~ UsageCompletion }

StakeholderMember = { Visibility? ~ KW_STAKEHOLDER ~ StakeholderUsage }
StakeholderUsage = { UsageDeclaration? ~ UsageCompletion }

ConcernDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONCERN ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

CaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CASE ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

CaseBody = { ";" | "{" ~ CaseBodyItem* ~ ResultExpressionMember? ~ "}" }

CaseBodyItem = {
    CalculationBodyItem
    | SubjectMember
    | ActorMember
    | ObjectiveMember
}

ObjectiveMember = { Visibility? ~ KW_OBJECTIVE ~ ObjectiveRequirementUsage }
ObjectiveRequirementUsage = { UsageDeclaration? ~ RequirementBody }

AnalysisCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ANALYSIS ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

VerificationCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VERIFICATION ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

UseCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_USE ~ KW_CASE ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

ViewDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VIEW ~ KW_DEF ~ DefinitionDeclaration ~ ViewBody
}

ViewBody = { ";" | "{" ~ ViewBodyItem* ~ "}" }

ViewBodyItem = {
    DefinitionBodyItem
    | ElementFilterMember
    | ViewRenderingMember
}

ViewRenderingMember = { Visibility? ~ KW_RENDER ~ ViewRenderingUsage }
ViewRenderingUsage = {
    OwnedReferenceSubsetting ~ FeatureSpecialization* ~ UsageBody
    | UsageDeclaration? ~ UsageCompletion
}

ViewpointDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VIEWPOINT ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

RenderingDefinition = {
    OccurrenceDefinitionPrefix ~ KW_RENDERING ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ExtendedDefinition = {
    BasicDefinitionPrefix? ~ DefinitionExtensionKeyword+ ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

// =============================================================================
// KERML TYPES (for standard library parsing)
// =============================================================================

// KerML Classifier: [abstract] classifier Name [:> Parent] { ... } | ;
ClassifierDefinition = {
    DefinitionPrefix ~ KW_CLASSIFIER ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML DataType: [abstract] datatype Name [:> Parent] { ... } | ;
DatatypeDefinition = {
    DefinitionPrefix ~ KW_DATATYPE ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Class: [abstract] class Name [:> Parent] { ... } | ;
ClassDefinition = {
    DefinitionPrefix ~ KW_CLASS ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Structure: [abstract] struct Name [:> Parent] { ... } | ;
StructDefinition = {
    DefinitionPrefix ~ KW_STRUCT ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Association: [abstract] assoc Name [:> Parent] { ... } | ;
AssociationDefinition = {
    DefinitionPrefix ~ KW_ASSOC ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML AssociationStructure: [abstract] assoc struct Name [:> Parent] { ... } | ;
AssociationStructDefinition = {
    DefinitionPrefix ~ KW_ASSOC ~ KW_STRUCT ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Multiplicity: multiplicity Name [bounds] { ... } | ;
MultiplicityDefinition = {
    KW_MULTIPLICITY ~ Identification? ~ OwnedMultiplicity? ~ DefinitionBody
}

// KerML Feature: [modifiers] feature [name] [:> Parent] [= value] { ... } | ;
// Uses RefPrefix to support all KerML feature modifiers (var, composite, portion, const, derived)
// Per KerML.xtext: (FeaturePrefix ('feature' | PrefixMetadataMember) FeatureDeclaration? | ...)
FeatureDefinition = {
    RefPrefix ~ KW_FEATURE ~ UsageDeclaration? ~ UsageCompletion
}

// KerML Behavior: [abstract] behavior Name [:> Parent] { ... } | ;
BehaviorDefinition = {
    DefinitionPrefix ~ KW_BEHAVIOR ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Function: [abstract] function Name [:> Parent] { ... } | ;
// Uses FunctionBody which supports return and result expression
FunctionDefinition = {
    DefinitionPrefix ~ KW_FUNCTION ~ DefinitionDeclaration ~ FunctionBody
}

// KerML Predicate: [abstract] predicate Name [:> Parent] { ... } | ;
PredicateDefinition = {
    DefinitionPrefix ~ KW_PREDICATE ~ DefinitionDeclaration ~ FunctionBody
}

// KerML Interaction: [abstract] interaction Name [:> Parent] { ... } | ;
InteractionDefinition = {
    DefinitionPrefix ~ KW_INTERACTION ~ DefinitionDeclaration ~ DefinitionBody
}

// KerML Metaclass: [abstract] metaclass Name [:> Parent] { ... } | ;
MetaclassDefinition = {
    DefinitionPrefix ~ KW_METACLASS ~ DefinitionDeclaration ~ DefinitionBody
}

// FunctionBody: Function and predicate body with return and result expression
FunctionBody = { ";" | "{" ~ FunctionBodyItem* ~ ResultExpressionMember? ~ "}" }

FunctionBodyItem = {
    DefinitionBodyItem
    | ReturnParameterMember
}

// =============================================================================
// USAGES
// =============================================================================

UsageElement = {
    NonOccurrenceUsageElement
    | OccurrenceUsageElement
}

// DefaultReferenceUsage MUST come first - it matches usages without explicit keyword
// like "in x: Type" or "out y[0..*]: SomeType"
NonOccurrenceUsageElement = {
    DefaultReferenceUsage
    | ReferenceUsage
    | AttributeUsage
    | EnumerationUsage
    | BindingConnectorAsUsage
    | SuccessionAsUsage
    | ExtendedUsage
    // KerML feature types (for standard library parsing)
    | StepUsage
    | ExpressionUsage
    | BooleanExpressionUsage
    | InvariantUsage
}

OccurrenceUsageElement = {
    StructureUsageElement
    | BehaviorUsageElement
}

StructureUsageElement = {
    OccurrenceUsage
    | IndividualUsage
    | PortionUsage
    | EventOccurrenceUsage
    | ItemUsage
    | PartUsage
    | PortUsage
    | ConnectionUsage
    | InterfaceUsage
    | AllocationUsage
    | SuccessionFlowUsage
    | FlowConnectionUsage
    | MessageUsage
    | ViewUsage
    | RenderingUsage
}

BehaviorUsageElement = {
    ActionUsage
    | CalculationUsage
    | StateUsage
    | ConstraintUsage
    | RequirementUsage
    | ConcernUsage
    | CaseUsage
    | AnalysisCaseUsage
    | VerificationCaseUsage
    | UseCaseUsage
    | ViewpointUsage
    | PerformActionUsage
    | ExhibitStateUsage
    | IncludeUseCaseUsage
    | AssertConstraintUsage
    | SatisfyRequirementUsage
}

VariantUsageElement = {
    VariantReference
    | NonOccurrenceUsageElement
    | OccurrenceUsageElement
}

VariantReference = { OwnedReferenceSubsetting ~ FeatureSpecialization* ~ UsageBody }

// Usage prefixes
UsagePrefix = { UnextendedUsagePrefix ~ UsageExtensionKeyword* }
UnextendedUsagePrefix = { EndUsagePrefix | BasicUsagePrefix }
BasicUsagePrefix = { RefPrefix ~ Reference? }
// KerML BasicFeaturePrefix: direction? derived? abstract? (composite|portion)? (var|const)?
// Note: FeaturePortion (the 'portion' keyword) is distinct from Portion (which is PortionKind: timeslice|snapshot)
RefPrefix = {
    FeatureDirectionKind? ~
    Derived? ~
    BasicDefinitionPrefix? ~
    (Composite | FeaturePortion)? ~
    (Variable | Constant)? ~
    Readonly?
}
Reference = { KW_REF }
EndUsagePrefix = { End ~ OwnedCrossingFeatureMember? }
UsageExtensionKeyword = { PrefixMetadataMember }
// OwnedCrossingFeatureMember must NOT match usage keywords (occurrence, port, etc.)
// It's only for cross-features with explicit prefix modifiers (in/out/ref/etc.)
OwnedCrossingFeatureMember = { !UsageKeywordLookahead ~ OwnedCrossingFeature }
OwnedCrossingFeature = { BasicUsagePrefix? ~ UsageDeclaration }

// Lookahead for usage keywords that should NOT be consumed by OwnedCrossingFeatureMember
// or DefaultReferenceUsage (prevents keywords from being parsed as identifiers)
UsageKeywordLookahead = {
    KW_OCCURRENCE | KW_ITEM | KW_PART | KW_PORT | KW_CONNECTION |
    KW_INTERFACE | KW_ALLOCATION | KW_FLOW | KW_ACTION | KW_STATE |
    KW_CONSTRAINT | KW_REQUIREMENT | KW_CONCERN | KW_CASE | KW_ANALYSIS |
    KW_VERIFICATION | KW_VIEW | KW_VIEWPOINT | KW_RENDERING | KW_EVENT |
    KW_ATTRIBUTE | KW_ENUM | KW_CALC | KW_REF | KW_SUCCESSION | KW_BIND |
    KW_BINDING | KW_ALLOCATE | KW_CONNECT | KW_PERFORM | KW_EXHIBIT |
    KW_INCLUDE | KW_SATISFY | KW_ASSERT | KW_USE |
    // Actor/Subject/Stakeholder keywords (for package body extension)
    KW_ACTOR | KW_SUBJECT | KW_STAKEHOLDER
}

UsageDeclaration = { FeatureDeclaration }

UsageCompletion = { ValuePart? ~ UsageBody }

UsageBody = { DefinitionBody }

// Specific usages
ReferenceUsage = {
    (EndUsagePrefix | RefPrefix) ~ KW_REF ~ UsageDeclaration? ~ UsageCompletion
}

// !UsageKeywordLookahead prevents matching when usage keyword follows (e.g., "inout part x")
// Otherwise DefaultReferenceUsage would match "inout" and treat "part" as an identifier name
DefaultReferenceUsage = {
    End? ~ RefPrefix ~ !UsageKeywordLookahead ~ UsageDeclaration? ~ UsageCompletion
}

AttributeUsage = {
    UsagePrefix ~ KW_ATTRIBUTE ~ UsageDeclaration? ~ UsageCompletion
}

EnumerationUsage = {
    UsagePrefix ~ KW_ENUM ~ UsageDeclaration? ~ UsageCompletion
}

OccurrenceUsage = {
    OccurrenceUsagePrefix ~ KW_OCCURRENCE ~ UsageDeclaration? ~ UsageCompletion
}

OccurrenceUsagePrefix = {
    (EndUsagePrefix | BasicOccurrenceUsagePrefix) ~ UsageExtensionKeyword*
}

BasicOccurrenceUsagePrefix = { BasicUsagePrefix ~ Individual? ~ Portion? }

Portion = { PortionKind }

IndividualUsage = {
    BasicUsagePrefix ~ Individual ~ UsageExtensionKeyword* ~ UsageDeclaration? ~ UsageCompletion
}

PortionUsage = {
    BasicUsagePrefix ~ Individual? ~ Portion ~ UsageExtensionKeyword* ~ UsageDeclaration? ~ UsageCompletion
}

EventOccurrenceUsage = {
    OccurrenceUsagePrefix ~ KW_EVENT ~ (
        // KW_OCCURRENCE must come first - otherwise "occurrence" matches as QualifiedName
        KW_OCCURRENCE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ UsageCompletion
}

ItemUsage = {
    OccurrenceUsagePrefix ~ KW_ITEM ~ UsageDeclaration? ~ UsageCompletion
}

PartUsage = {
    OccurrenceUsagePrefix ~ KW_PART ~ UsageDeclaration? ~ UsageCompletion
}

PortUsage = {
    OccurrenceUsagePrefix ~ KW_PORT ~ UsageDeclaration? ~ UsageCompletion
}

ConnectionUsage = {
    OccurrenceUsagePrefix ~ (
        KW_CONNECTION ~ UsageDeclaration? ~ ValuePart? ~ (KW_CONNECT ~ ConnectorPart)?
        | KW_CONNECT ~ ConnectorPart
    ) ~ UsageBody
}

ConnectorPart = { BinaryConnectorPart | NaryConnectorPart }

BinaryConnectorPart = { ConnectorEndMember ~ KW_TO ~ ConnectorEndMember }

NaryConnectorPart = { "(" ~ ConnectorEndMember ~ ("," ~ ConnectorEndMember)+ ~ ")" }

ConnectorEndMember = { ConnectorEnd }

ConnectorEnd = {
    OwnedCrossMultiplicityMember? ~ (RegularName ~ ReferencesToken)? ~ OwnedReferenceSubsetting
}

OwnedCrossMultiplicityMember = { OwnedCrossMultiplicity }

OwnedCrossMultiplicity = { OwnedMultiplicity }

InterfaceUsage = {
    OccurrenceUsagePrefix ~ KW_INTERFACE ~ UsageDeclaration? ~ (KW_CONNECT ~ InterfacePart)? ~ InterfaceBody
}

InterfacePart = { BinaryInterfacePart | NaryInterfacePart }

BinaryInterfacePart = { InterfaceEndMember ~ KW_TO ~ InterfaceEndMember }

NaryInterfacePart = { "(" ~ InterfaceEndMember ~ ("," ~ InterfaceEndMember)+ ~ ")" }

InterfaceEndMember = { InterfaceEnd }

InterfaceEnd = {
    OwnedCrossMultiplicityMember? ~ (RegularName ~ ReferencesToken)? ~ OwnedReferenceSubsetting
}

AllocationUsage = {
    OccurrenceUsagePrefix ~ (
        KW_ALLOCATION ~ UsageDeclaration? ~ (KW_ALLOCATE ~ ConnectorPart)?
        | KW_ALLOCATE ~ ConnectorPart
    ) ~ UsageBody
}

FlowConnectionUsage = {
    OccurrenceUsagePrefix ~ KW_FLOW ~ FlowConnectionDeclaration ~ DefinitionBody
}

SuccessionFlowUsage = {
    OccurrenceUsagePrefix ~ KW_SUCCESSION ~ KW_FLOW ~ FlowConnectionDeclaration ~ DefinitionBody
}

MessageUsage = {
    OccurrenceUsagePrefix ~ KW_MESSAGE ~ MessageDeclaration ~ DefinitionBody
}

MessageDeclaration = {
    MessageEventMember ~ KW_TO ~ MessageEventMember
    | UsageDeclaration? ~ ValuePart? ~ (KW_OF ~ PayloadFeatureMember)? ~
        (KW_FROM ~ MessageEventMember ~ KW_TO ~ MessageEventMember)?
}

PayloadFeatureMember = { ItemFeature }

MessageEventMember = { OwnedExpression }

// FlowConnectionDeclaration: Ordered alternatives for PEG
// CRITICAL: Try keyword-starting patterns FIRST to prevent keywords being parsed as identifiers
FlowConnectionDeclaration = {
    // Pattern 1: Bare 'from a.x to b.y'
    KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 2: 'of item from ... to ...' (no declaration)
    | KW_OF ~ ItemFeatureMember ~ KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 3: 'of item' only (no endpoints)
    | KW_OF ~ ItemFeatureMember
    // Pattern 4: With declaration then 'from'
    | UsageDeclaration ~ ValuePart? ~ (KW_OF ~ ItemFeatureMember)? ~
        KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 5: With declaration then 'of' then 'from'
    | UsageDeclaration ~ ValuePart? ~ KW_OF ~ ItemFeatureMember ~
        KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 6: Direct endpoints 'a.x to b.y' (no 'from')
    | FlowEndMember ~ KW_TO ~ FlowEndMember
    // Pattern 7: Declaration with optional 'of' (no endpoints)
    | UsageDeclaration ~ ValuePart? ~ (KW_OF ~ ItemFeatureMember)?
}

ItemFeatureMember = { ItemFeature }

ItemFeature = {
    Identification? ~ PayloadFeatureSpecializationPart ~ ValuePart?
    | Identification? ~ ValuePart
    | OwnedFeatureTyping ~ OwnedMultiplicity?
    | OwnedMultiplicity ~ OwnedFeatureTyping
}

PayloadFeatureSpecializationPart = {
    FeatureSpecialization+ ~ (MultiplicityPart ~ FeatureSpecialization*)?
    | MultiplicityPart ~ FeatureSpecialization+
}

FlowEndMember = { FlowEnd }

FlowEnd = { FlowEndSubsetting? ~ FlowFeatureMember }

FlowEndSubsetting = { QualifiedName ~ "." | FeatureChainPrefix }

FlowFeatureMember = { FlowFeature }

FlowFeature = { FlowRedefinition }

FlowRedefinition = { QualifiedName }

ViewUsage = {
    OccurrenceUsagePrefix ~ KW_VIEW ~ UsageDeclaration? ~ ValuePart? ~ ViewBody
}

RenderingUsage = {
    OccurrenceUsagePrefix ~ KW_RENDERING ~ UsageDeclaration? ~ UsageCompletion
}

ActionUsage = {
    OccurrenceUsagePrefix ~ KW_ACTION ~ UsageDeclaration? ~ ValuePart? ~ ActionBody
}

PerformActionUsage = {
    OccurrenceUsagePrefix ~ KW_PERFORM ~ (
        KW_ACTION ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ ActionBody
}

CalculationUsage = {
    OccurrenceUsagePrefix ~ KW_CALC ~ UsageDeclaration? ~ ValuePart? ~ CalculationBody
}

StateUsage = {
    OccurrenceUsagePrefix ~ KW_STATE ~ UsageDeclaration? ~ ValuePart? ~ StateBody
}

ExhibitStateUsage = {
    OccurrenceUsagePrefix ~ KW_EXHIBIT ~ (
        KW_STATE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ StateBody
}

ConstraintUsage = {
    OccurrenceUsagePrefix ~ KW_CONSTRAINT ~ UsageDeclaration? ~ ValuePart? ~ CalculationBody
}

AssertConstraintUsage = {
    OccurrenceUsagePrefix ~ KW_ASSERT ~ KW_NOT? ~ (
        KW_CONSTRAINT ~ UsageDeclaration? ~ ValuePart?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ CalculationBody
}

RequirementUsage = {
    OccurrenceUsagePrefix ~ KW_REQUIREMENT ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

SatisfyRequirementUsage = {
    OccurrenceUsagePrefix ~ KW_ASSERT? ~ KW_NOT? ~ KW_SATISFY ~ (
        KW_REQUIREMENT ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ (KW_BY ~ SatisfactionSubjectMember)? ~ RequirementBody
}

SatisfactionSubjectMember = { SatisfactionParameter }

SatisfactionParameter = { SatisfactionFeatureValue }

SatisfactionFeatureValue = { OwnedExpression }

ConcernUsage = {
    OccurrenceUsagePrefix ~ KW_CONCERN ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

CaseUsage = {
    OccurrenceUsagePrefix ~ KW_CASE ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

AnalysisCaseUsage = {
    OccurrenceUsagePrefix ~ KW_ANALYSIS ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

VerificationCaseUsage = {
    OccurrenceUsagePrefix ~ KW_VERIFICATION ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

UseCaseUsage = {
    OccurrenceUsagePrefix ~ KW_USE ~ KW_CASE ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

IncludeUseCaseUsage = {
    OccurrenceUsagePrefix ~ KW_INCLUDE ~ (
        KW_USE ~ KW_CASE ~ UsageDeclaration?
        | OwnedReferenceSubsetting ~ FeatureSpecializationPart?
    ) ~ ValuePart? ~ CaseBody
}

ViewpointUsage = {
    OccurrenceUsagePrefix ~ KW_VIEWPOINT ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

BindingConnectorAsUsage = {
    UsagePrefix ~ (KW_BINDING ~ UsageDeclaration?)? ~
    KW_BIND ~ ConnectorEndMember ~ "=" ~ ConnectorEndMember ~ DefinitionBody
}

SuccessionAsUsage = {
    UsagePrefix ~ (KW_SUCCESSION ~ UsageDeclaration?)? ~
    KW_FIRST ~ ConnectorEndMember ~ KW_THEN ~ ConnectorEndMember ~ DefinitionBody
}

ExtendedUsage = {
    UnextendedUsagePrefix ~ UsageExtensionKeyword+ ~ UsageDeclaration? ~ UsageCompletion
}

// =============================================================================
// KERML FEATURE USAGES (for standard library parsing)
// =============================================================================

// KerML Step: [modifiers] step [name] [: Type] [= value] { ... } | ;
StepUsage = {
    UsagePrefix ~ KW_STEP ~ UsageDeclaration? ~ ValuePart? ~ DefinitionBody
}

// KerML Expression: [modifiers] expr [name] [: Type] [= value] { ... } | ;
ExpressionUsage = {
    UsagePrefix ~ KW_EXPR ~ UsageDeclaration? ~ ValuePart? ~ FunctionBody
}

// KerML BooleanExpression: [modifiers] bool [name] [: Type] [= value] { ... } | ;
BooleanExpressionUsage = {
    UsagePrefix ~ KW_BOOL ~ UsageDeclaration? ~ ValuePart? ~ FunctionBody
}

// KerML Invariant: [modifiers] inv [true|false] [name] [: Type] [= value] { ... } | ;
InvariantUsage = {
    UsagePrefix ~ KW_INV ~ (KW_TRUE | KW_FALSE)? ~ UsageDeclaration? ~ ValuePart? ~ FunctionBody
}

// =============================================================================
// FEATURES
// =============================================================================

// FeatureDeclaration matches xtext:
// Identification FeatureSpecializationPart? | FeatureSpecializationPart
// Note: FeatureSpecializationPart first to handle contextual keywords (redefines, etc.)
// When input starts with specialization syntax (:, :>, :>>, etc.), match anonymous feature.
// Otherwise, match Identification with optional specialization.
// FeatureRelationshipPart* is appended for chains, inverse of, featured by
FeatureDeclaration = {
    FeatureSpecializationPart ~ FeatureRelationshipPart*
    | Identification ~ FeatureSpecializationPart? ~ FeatureRelationshipPart*
}

// KerML Feature Relationship Parts (chains, inverse of, featured by)
// These follow the FeatureSpecializationPart in FeatureDeclaration
FeatureRelationshipPart = {
    ChainingPart
    | InvertingPart
    | TypeFeaturingPart
}

// chains <qualified-name> | chains <feature-chain>
ChainingPart = { KW_CHAINS ~ (OwnedFeatureChain | QualifiedName) }

// inverse of <feature>
InvertingPart = { KW_INVERSE ~ KW_OF ~ (OwnedFeatureChain | QualifiedName) }

// featured by <type> [, <type>]*
TypeFeaturingPart = { KW_FEATURED ~ KW_BY ~ QualifiedName ~ ("," ~ QualifiedName)* }

FeatureSpecializationPart = {
    FeatureSpecialization+ ~ (MultiplicityPart ~ FeatureSpecialization*)?
    | MultiplicityPart ~ FeatureSpecialization*
}

FeatureSpecialization = {
    Typings
    | Subsettings
    | References_
    | Crosses
    | Redefinitions
}

Typings = { TypedBy ~ ("," ~ FeatureTyping)* }

TypedBy = { DefinedByToken ~ FeatureTyping }

FeatureTyping = { OwnedFeatureTyping | ConjugatedPortTyping }

OwnedFeatureTyping = { FeatureType }

// OwnedFeatureChain first - longer match (a.b.c) vs QualifiedName (a or A::B)
FeatureType = { OwnedFeatureChain | QualifiedName }

ConjugatedPortTyping = { "~" ~ QualifiedName }

Subsettings = { Subsets ~ ("," ~ OwnedSubsetting)* }

Subsets = { SubsetsToken ~ OwnedSubsetting }

OwnedSubsetting = { OwnedFeatureChain | QualifiedName }

References_ = { ReferencesToken ~ OwnedReferenceSubsetting }

OwnedReferenceSubsetting = { OwnedFeatureChain | QualifiedName }

Crosses = { CrossesToken ~ OwnedCrossSubsetting }

OwnedCrossSubsetting = { OwnedFeatureChain | QualifiedName }

Redefinitions = { Redefines ~ ("," ~ OwnedRedefinition)* }

Redefines = { RedefinesToken ~ OwnedRedefinition }

OwnedRedefinition = { OwnedFeatureChain | QualifiedName }

// Feature chains
OwnedFeatureChain = { FeatureChain }

FeatureChain = { OwnedFeatureChaining ~ ("." ~ OwnedFeatureChaining)+ }

FeatureChainPrefix = { (OwnedFeatureChaining ~ ".")+ ~ OwnedFeatureChaining ~ "." }

OwnedFeatureChaining = { QualifiedName }

// Multiplicity
MultiplicityPart = {
    OwnedMultiplicity ~ MultiplicityProperties?
    | MultiplicityProperties
}

OwnedMultiplicity = { MultiplicityRange }

MultiplicityRange = { "[" ~ MultiplicityExpressionMember ~ "]" }

MultiplicityExpressionMember = { OwnedExpression }

// Value part
ValuePart = { FeatureValue }

FeatureValue = {
    ("=" | ":=" | (KW_DEFAULT ~ ("=" | ":=")?)) ~ OwnedExpression
}

// =============================================================================
// ANNOTATIONS
// =============================================================================

AnnotatingElement = {
    Comment
    | Documentation
    | TextualRepresentation
    | MetadataUsage
}

Comment = {
    (KW_COMMENT ~ Identification? ~ (KW_ABOUT ~ Annotation ~ ("," ~ Annotation)*)?)? ~
    (KW_LOCALE ~ STRING_VALUE)? ~
    REGULAR_COMMENT_BODY
}

Documentation = {
    KW_DOC ~ Identification? ~
    (KW_LOCALE ~ STRING_VALUE)? ~
    REGULAR_COMMENT_BODY
}

TextualRepresentation = {
    (KW_REP ~ Identification?)? ~ KW_LANGUAGE ~ STRING_VALUE ~ REGULAR_COMMENT_BODY
}

Annotation = { QualifiedName }

// Metadata
PrefixMetadata = { PrefixMetadataMember+ }

PrefixMetadataMember = { PrefixMetadataUsage }

PrefixMetadataUsage = { "#" ~ MetadataTyping }

MetadataTyping = { QualifiedName }

MetadataUsage = {
    PrefixMetadata? ~ (KW_METADATA | "@") ~ MetadataUsageDeclaration ~
    (KW_ABOUT ~ Annotation ~ ("," ~ Annotation)*)? ~
    MetadataBody
}

MetadataUsageDeclaration = { (Identification? ~ DefinedByToken)? ~ MetadataTyping }

MetadataBody = { ";" | "{" ~ MetadataBodyItem* ~ "}" }

MetadataBodyItem = {
    DefinitionMember
    | RelationshipMember
    | AnnotatingMember
    | MetadataBodyUsageMember
    | AliasMember
    | Import
}

MetadataBodyUsageMember = { MetadataBodyUsage }

MetadataBodyUsage = {
    KW_REF? ~ RedefinesToken? ~ OwnedRedefinition ~
    FeatureSpecializationPart? ~ ValuePart? ~ MetadataBody
}

// =============================================================================
// RELATIONSHIPS (Dependencies)
// =============================================================================

Dependency = {
    PrefixMetadataAnnotation* ~ KW_DEPENDENCY ~ (Identification? ~ KW_FROM)? ~
    QualifiedName ~ ("," ~ QualifiedName)* ~ KW_TO ~
    QualifiedName ~ ("," ~ QualifiedName)* ~
    RelationshipBody
}

PrefixMetadataAnnotation = { PrefixMetadataUsage }

RelationshipBody = { ";" | "{" ~ RelationshipBodyElement* ~ "}" }

RelationshipBodyElement = { AnnotatingMember }

// =============================================================================
// ACTION NODES
// =============================================================================

ActionNode = {
    SendNode
    | AcceptNode
    | AssignmentNode
    | TerminateNode
    | IfNode
    | WhileLoopNode
    | ForLoopNode
    | ControlNode
}

ActionNodePrefix = { OccurrenceUsagePrefix ~ ActionNodeUsageDeclaration? }

ActionNodeUsageDeclaration = { KW_ACTION ~ UsageDeclaration? }

SendNode = {
    OccurrenceUsagePrefix ~ ActionNodeUsageDeclaration? ~
    KW_SEND ~ NodeParameterMember ~
    (KW_VIA ~ NodeParameterMember)? ~
    (KW_TO ~ NodeParameterMember)? ~
    ActionBody
}

AcceptNode = {
    OccurrenceUsagePrefix ~ ActionNodeUsageDeclaration? ~
    KW_ACCEPT ~ AcceptParameterPart ~ ActionBody
}

AcceptParameterPart = {
    PayloadParameterMember ~ (KW_VIA ~ NodeParameterMember)?
}

PayloadParameterMember = { PayloadParameter }

PayloadParameter = {
    // Prevent Identification from consuming trigger keywords (at/after/when)
    // Use negative lookahead: if next token is TriggerKind, don't match as identifier
    (!TriggerKind ~ Identification)? ~ TriggerValuePart
    | Identification? ~ PayloadFeatureSpecializationPart ~ ValuePart?
    | Identification ~ ValuePart?
}

TriggerValuePart = { TriggerFeatureValue }

TriggerFeatureValue = { TriggerExpression }

TriggerExpression = {
    TriggerKind ~ ArgumentMember
}

TriggerKind = { KW_AT | KW_AFTER | KW_WHEN }

NodeParameterMember = { NodeParameter }

NodeParameter = { FeatureBinding }

FeatureBinding = { OwnedExpression }

AssignmentNode = {
    OccurrenceUsagePrefix ~ ActionNodeUsageDeclaration? ~
    KW_ASSIGN ~ FeatureChainMember ~ ":=" ~ NodeParameterMember ~ ActionBody
}

// OwnedFeatureChain must come first - it's a longer match (a.b.c)
// while QualifiedName only handles a single name or A::B paths
FeatureChainMember = { OwnedFeatureChain | QualifiedName }

TerminateNode = {
    ActionNodePrefix ~ KW_TERMINATE ~ NodeParameterMember? ~ ActionBody
}

IfNode = {
    ActionNodePrefix ~ KW_IF ~ ExpressionParameterMember ~
    ActionBodyParameterMember ~
    (KW_ELSE ~ (ActionBodyParameterMember | IfNodeParameterMember))?
}

ExpressionParameterMember = { OwnedExpression }

ActionBodyParameterMember = { ActionBodyParameter }

ActionBodyParameter = { (KW_ACTION ~ UsageDeclaration?)? ~ "{" ~ ActionBodyItem* ~ "}" }

IfNodeParameterMember = { IfNode }

WhileLoopNode = {
    ActionNodePrefix ~ (
        KW_WHILE ~ ExpressionParameterMember
        | KW_LOOP
    ) ~ ActionBodyParameterMember ~
    (KW_UNTIL ~ ExpressionParameterMember ~ ";")?
}

ForLoopNode = {
    ActionNodePrefix ~ KW_FOR ~ ForVariableDeclarationMember ~
    KW_IN ~ NodeParameterMember ~ ActionBodyParameterMember
}

ForVariableDeclarationMember = { ForVariableDeclaration }

ForVariableDeclaration = { UsageDeclaration }

ControlNode = { MergeNode | DecisionNode | JoinNode | ForkNode }

ControlNodePrefix = { RefPrefix ~ Individual? ~ Portion? ~ PrefixMetadata? }

MergeNode = { ControlNodePrefix ~ KW_MERGE ~ UsageDeclaration? ~ ActionNodeBody }

DecisionNode = { ControlNodePrefix ~ KW_DECIDE ~ UsageDeclaration? ~ ActionNodeBody }

JoinNode = { ControlNodePrefix ~ KW_JOIN ~ UsageDeclaration? ~ ActionNodeBody }

ForkNode = { ControlNodePrefix ~ KW_FORK ~ UsageDeclaration? ~ ActionNodeBody }

ActionNodeBody = { ";" | "{" ~ AnnotatingMember* ~ "}" }

// =============================================================================
// TRANSITIONS
// =============================================================================

TransitionUsage = {
    KW_TRANSITION ~
    // Try keyword alternatives before TransitionSourceMember can consume them
    (UsageDeclaration ~ KW_FIRST | KW_FIRST)? ~
    TransitionSourceMember ~
    TriggerActionMember? ~
    GuardExpressionMember? ~
    EffectBehaviorMember? ~
    KW_THEN ~ TransitionSuccessionMember ~
    ActionBody
}

TransitionSourceMember = { QualifiedName | OwnedFeatureChain }

TriggerActionMember = { KW_ACCEPT ~ TriggerAction }

TriggerAction = { AcceptParameterPart }

GuardExpressionMember = { KW_IF ~ OwnedExpression }

EffectBehaviorMember = { KW_DO ~ EffectBehaviorUsage }

// EffectBehaviorUsage: Action after 'do' in transitions
// Matches xtext: EmptyActionUsage | PerformedActionUsage ( '{' ActionBodyItem* '}' )?
// Supports patterns like: do action undockFromStation : UndockFromStation { ... }
EffectBehaviorUsage = {
    EffectPerformedActionUsage ~ ("{" ~ ActionBodyItem* ~ "}")?
    | ("{" ~ ActionBodyItem* ~ "}")?  // Empty action body
}

// EffectPerformedActionUsage: Performed action in effect context
// Matches xtext PerformedActionUsage with PerformActionUsageDeclaration
EffectPerformedActionUsage = {
    KW_ACTION ~ UsageDeclaration? ~ ValuePart?
    | OwnedReferenceSubsetting ~ FeatureSpecializationPart? ~ ValuePart?
    | AcceptNodeDeclaration
    | SendNodeDeclaration
    | AssignmentNodeDeclaration
}

TransitionSuccessionMember = { TransitionSuccession }

TransitionSuccession = { ConnectorEndMember }

// =============================================================================
// TARGET SUCCESSIONS (for action chaining with 'then')
// =============================================================================

// TargetSuccessionMember: [visibility] ActionTargetSuccession
// Used after actions in ActionBodyItem to chain with 'then'
TargetSuccessionMember = { Visibility? ~ ActionTargetSuccession }

// ActionTargetSuccession: (TargetSuccession | GuardedTargetSuccession | DefaultTargetSuccession)
// Returns a Usage that contains the succession relationship
// The body is either inline with the target or follows as UsageBody
ActionTargetSuccession = {
    TargetSuccession
    | GuardedTargetSuccession
    | DefaultTargetSuccession
}

// TargetSuccession: [multiplicity?] 'then' target [body]
// The target can be:
// - A reference to an action: then done;
// - An inline action usage: then action a { }
// - A perform action: then perform body;
// - An assignment: then assign x := 1;
// - An inline while/for loop: then action whileLoop while ...
TargetSuccession = {
    OwnedMultiplicity? ~ KW_THEN ~ SuccessionTarget
}

// GuardedTargetSuccession: if condition then target [body]
GuardedTargetSuccession = {
    GuardExpressionMember ~ KW_THEN ~ SuccessionTarget
}

// DefaultTargetSuccession: else target [body]
DefaultTargetSuccession = {
    KW_ELSE ~ SuccessionTarget
}

// SuccessionTarget: The target of a succession with its body
// Can be an inline action node or a simple target with UsageBody
SuccessionTarget = {
    // Inline while loop: then action whileLoop while ... { }
    SuccessionWhileLoopNode
    // Inline for loop: then action forLoop for ... { }
    | SuccessionForLoopNode
    // Inline if node: then action ifAction if ... { }
    | SuccessionIfNode
    // Portion usages: then snapshot x; then timeslice y { }
    | SuccessionPortionUsage ~ UsageBody
    // State usage: then state x { }
    | SuccessionStateUsage ~ UsageBody
    // Action nodes with simple body:
    // - perform body;
    // - assign x := 1;
    | SuccessionActionNodeDeclaration ~ UsageBody
    // Full action usage: then [private] action a { }
    | SuccessionActionUsageDeclaration ~ UsageBody
    // Simple reference: then done;
    | ConnectorEndMember ~ UsageBody
}

// SuccessionWhileLoopNode: WhileLoopNode as succession target
// Pattern: [visibility] [action name] while/loop ... { }
SuccessionWhileLoopNode = {
    SuccessionActionNodePrefix ~
    (KW_WHILE ~ ExpressionParameterMember | KW_LOOP) ~
    ActionBodyParameterMember ~
    (KW_UNTIL ~ ExpressionParameterMember ~ ";")?
}

// SuccessionForLoopNode: ForLoopNode as succession target
// Pattern: [visibility] [action name] for ... { }
SuccessionForLoopNode = {
    SuccessionActionNodePrefix ~
    KW_FOR ~ ForVariableDeclarationMember ~
    KW_IN ~ NodeParameterMember ~
    ActionBodyParameterMember
}

// SuccessionIfNode: IfNode as succession target
// Pattern: [visibility] [action name] if ... { } [else ...]
SuccessionIfNode = {
    SuccessionActionNodePrefix ~
    KW_IF ~ ExpressionParameterMember ~
    ActionBodyParameterMember ~
    (KW_ELSE ~ (ActionBodyParameterMember | IfNodeParameterMember))?
}

// SuccessionActionNodePrefix: Prefix for action nodes in succession
// Includes optional visibility and action declaration
SuccessionActionNodePrefix = { Visibility? ~ ActionNodeUsageDeclaration? }

// SuccessionActionNodeDeclaration: Action node declarations (without body)
SuccessionActionNodeDeclaration = {
    PerformActionNodePrefix ~ OwnedReferenceSubsetting ~ FeatureSpecializationPart? ~ ValuePart?
    | PerformActionNodePrefix ~ KW_ACTION ~ UsageDeclaration? ~ ValuePart?
    | AssignmentNodeDeclaration
    | SendNodeDeclaration
    | AcceptNodeDeclaration
}

// PerformActionNodePrefix captures: [visibility] perform
PerformActionNodePrefix = { Visibility? ~ KW_PERFORM }

// AssignmentNodeDeclaration: assign target := value
AssignmentNodeDeclaration = { Visibility? ~ KW_ASSIGN ~ FeatureChainMember ~ ":=" ~ NodeParameterMember }

// SendNodeDeclaration: send value [via port] [to target]
SendNodeDeclaration = { Visibility? ~ KW_SEND ~ NodeParameterMember ~ (KW_VIA ~ NodeParameterMember)? ~ (KW_TO ~ NodeParameterMember)? }

// AcceptNodeDeclaration: accept payload [via port]
AcceptNodeDeclaration = { Visibility? ~ KW_ACCEPT ~ AcceptParameterPart }

// SuccessionActionUsageDeclaration: Action usage declaration (without body)
// Handles: then [private] action a
SuccessionActionUsageDeclaration = {
    Visibility? ~ KW_ACTION ~ UsageDeclaration? ~ ValuePart?
}

// SuccessionPortionUsage: Portion usage (snapshot/timeslice) in succession
// Handles: then snapshot x, then timeslice y
SuccessionPortionUsage = {
    Visibility? ~ PortionKind ~ UsageDeclaration? ~ ValuePart?
}

// SuccessionStateUsage: State usage in succession
// Handles: then state x
SuccessionStateUsage = {
    Visibility? ~ KW_STATE ~ UsageDeclaration? ~ ValuePart?
}

// =============================================================================
// EXPRESSIONS
// =============================================================================

OwnedExpression = { ConditionalExpression }

OwnedExpressionMember = { OwnedExpression }

OwnedExpressionReference = { OwnedExpressionMember }

// Conditional Expressions
// ConcreteConditionalExpression must come first - otherwise "if" matches as identifier
ConditionalExpression = {
    ConcreteConditionalExpression
    | NullCoalescingExpression
}

ConcreteConditionalExpression = {
    KW_IF ~ NullCoalescingExpression ~ "?" ~ OwnedExpressionReference ~
    KW_ELSE ~ OwnedExpressionReference
}

NullCoalescingExpression = {
    ImpliesExpression ~ ("??" ~ ImpliesExpressionReference)*
}

ImpliesExpressionReference = { ImpliesExpressionMember }

ImpliesExpressionMember = { ImpliesExpression }

// Logical Expressions
ImpliesExpression = {
    OrExpression ~ (KW_IMPLIES ~ OrExpressionReference)*
}

OrExpressionReference = { OrExpressionMember }

OrExpressionMember = { OrExpression }

OrExpression = {
    XorExpression ~ (("|" ~ XorExpression) | (KW_OR ~ XorExpressionReference))*
}

XorExpressionReference = { XorExpressionMember }

XorExpressionMember = { XorExpression }

XorExpression = {
    AndExpression ~ (KW_XOR ~ AndExpression)*
}

// AndExpression: supports && (conditional), & (bitwise), and 'and' (keyword)
// Note: "&&" must come BEFORE "&" (longer match first)
AndExpression = {
    EqualityExpression ~ (("&&" ~ EqualityExpressionReference) | ("&" ~ EqualityExpression) | (KW_AND ~ EqualityExpressionReference))*
}

EqualityExpressionReference = { EqualityExpressionMember }

EqualityExpressionMember = { EqualityExpression }

// Equality Expressions
EqualityExpression = {
    ClassificationExpression ~ (EqualityOperator ~ ClassificationExpression)*
}

// Classification Expressions
ClassificationExpression = {
    RelationalExpression ~ (
        (ClassificationTestOperator ~ TypeReferenceMember)
        | (KW_AS ~ TypeResultMember)
    )?
    | ClassificationTestOperator ~ TypeReferenceMember
    | MetadataReference ~ "@@" ~ TypeReferenceMember
    | KW_AS ~ TypeResultMember
    | MetadataReference ~ KW_META ~ TypeResultMember
}

TypeReferenceMember = { TypeReferenceFeature }

TypeResultMember = { TypeReferenceFeature }

TypeReferenceFeature = { ReferenceTyping }

ReferenceTyping = { QualifiedName }

MetadataReference = { QualifiedName }

// Relational Expressions
RelationalExpression = {
    RangeExpression ~ (RelationalOperator ~ RangeExpression)*
}

// Range Expressions
RangeExpression = {
    AdditiveExpression ~ (".." ~ AdditiveExpression)?
}

// Arithmetic Expressions
AdditiveExpression = {
    MultiplicativeExpression ~ (("+" | "-") ~ MultiplicativeExpression)*
}

MultiplicativeExpression = {
    ExponentiationExpression ~ (("*" | "/" | "%") ~ ExponentiationExpression)*
}

ExponentiationExpression = {
    UnaryExpression ~ (("**" | "^") ~ ExponentiationExpression)?
}

// Unary Expressions
UnaryExpression = {
    UnaryOperator ~ ExtentExpression
    | ExtentExpression
}

// Extent Expressions
ExtentExpression = {
    KW_ALL ~ TypeResultMember
    | PrimaryExpression
}

// Primary Expressions
PrimaryExpression = {
    BaseExpression ~
    ("." ~ FeatureChainMember)? ~
    (
        ("#" ~ "(" ~ SequenceExpression ~ ")")
        | ("[" ~ SequenceExpression ~ "]")
        | ("->" ~ ReferenceTyping ~ (ExpressionBodyMember | FunctionReferenceMember | ArgumentList))
        | ("." ~ ExpressionBodyMember)
        | (".?" ~ ExpressionBodyMember)
    )* ~
    ("." ~ FeatureChainMember)?
}

// Base Expressions
// Note: InvocationExpression must come BEFORE FeatureReferenceExpression
// because InvocationExpression is more specific (name + argument list)
// and FeatureReferenceExpression would match just the name, leaving ()
BaseExpression = {
    NullExpression
    | LiteralExpression
    | MetadataAccessExpression
    | InvocationExpression
    | FeatureReferenceExpression
    | BodyExpression
    | "(" ~ SequenceExpression ~ ")"
}

// Null Expressions
NullExpression = { KW_NULL | "(" ~ ")" }

// Literal Expressions
LiteralExpression = {
    LiteralBoolean
    | LiteralString
    | LiteralNumber
    | LiteralInfinity
}

LiteralBoolean = { KW_TRUE | KW_FALSE }

LiteralString = { STRING_VALUE }

LiteralNumber = { NUMBER }

LiteralInfinity = { "*" }

// Feature Reference Expressions
FeatureReferenceExpression = { FeatureReferenceMember }

FeatureReferenceMember = { QualifiedName }

// Metadata Access Expressions
MetadataAccessExpression = { QualifiedName ~ "." ~ KW_METADATA }

// Invocation Expressions
InvocationExpression = { OwnedFeatureTyping ~ ArgumentList }

ArgumentList = { "(" ~ (PositionalArgumentList | NamedArgumentList)? ~ ")" }

PositionalArgumentList = { ArgumentMember ~ ("," ~ ArgumentMember)* }

ArgumentMember = { Argument }

Argument = { ArgumentValue }

ArgumentValue = { OwnedExpression }

NamedArgumentList = { NamedArgumentMember ~ ("," ~ NamedArgumentMember)* }

NamedArgumentMember = { NamedArgument }

NamedArgument = { ParameterRedefinition ~ "=" ~ ArgumentValue }

ParameterRedefinition = { QualifiedName }

// Body Expressions
BodyExpression = { ExpressionBodyMember }

ExpressionBodyMember = { ExpressionBody }

ExpressionBody = { "{" ~ CalculationBodyItem* ~ ResultExpressionMember? ~ "}" }

// Function Reference
FunctionReferenceMember = { FunctionReference }

FunctionReference = { ReferenceTyping }

// Sequence Expressions
SequenceExpression = {
    OwnedExpression ~ (("," ~ SequenceExpression) | ",")?
}