// SysML v2 Grammar for pest
// Based on SySide Langium grammar (4244 lines)
// This is a PEG grammar that closely follows the official specification
//
// This grammar is generated by build.rs, combining manual fragments with
// auto-generated rules for keywords, operators, and enums.

// =============================================================================
// WHITESPACE AND COMMENTS
// =============================================================================

WHITESPACE = _{ " " | "\t" | NEWLINE }
NEWLINE = _{ "\r\n" | "\n" | "\r" }

// Single-line comment: // ...
SL_COMMENT = _{ "//" ~ !("*") ~ (!NEWLINE ~ ANY)* }

// Multi-line comment: /* ... */
ML_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Single-line note: //* ... (hidden)
SL_NOTE = _{ "//*" ~ (!NEWLINE ~ ANY)* }

// Multi-line note: //* ... */ (hidden)
ML_NOTE = _{ "//*" ~ (!"*/" ~ ANY)* ~ "*/" }

COMMENT = _{ ML_COMMENT | SL_COMMENT }

// =============================================================================
// TERMINALS
// =============================================================================

// Identifiers
ID = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Unrestricted name: 'name with spaces'
UNRESTRICTED_NAME = @{ "'" ~ (ESCAPE_SEQUENCE | (!("'" | "\\") ~ ANY))* ~ "'" }

// String literals
STRING_VALUE = @{ "\"" ~ (ESCAPE_SEQUENCE | (!("\"" | "\\") ~ ANY))* ~ "\"" }

// Escape sequences
ESCAPE_SEQUENCE = _{ "\\" ~ ("'" | "\"" | "b" | "f" | "t" | "n" | "r" | "\\") }

// Numbers
DECIMAL = @{ ASCII_DIGIT+ }
FRACTION = @{ "." ~ DECIMAL }
FLOAT = @{ DECIMAL ~ FRACTION? | FRACTION }
EXPONENT = @{ ("e" | "E") ~ ("-" | "+")? ~ DECIMAL }
NUMBER = @{ FLOAT ~ EXPONENT? }

// Regular comment body for textual annotations
REGULAR_COMMENT_BODY = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// =============================================================================
// NAMES AND REFERENCES
// =============================================================================

Name = { ID | UNRESTRICTED_NAME }

// Short name: <name>
ShortName = { "<" ~ Name ~ ">" }

// Regular name: just the name
RegularName = { Name }

// Identification: <shortName> name | name | <shortName>
Identification = { ShortName ~ RegularName? | RegularName }

// Qualified reference chain: A::B::C
QualifiedName = { Name ~ ("::" ~ Name)* }

// =============================================================================
// KEYWORDS (Generated from SysML/KerML xtext files)
// =============================================================================

KW_ABOUT = { "about" }
KW_ABSTRACT = { "abstract" }
KW_ACCEPT = { "accept" }
KW_ACTION = { "action" }
KW_ACTOR = { "actor" }
KW_AFTER = { "after" }
KW_ALIAS = { "alias" }
KW_ALL = { "all" }
KW_ALLOCATE = { "allocate" }
KW_ALLOCATION = { "allocation" }
KW_ANALYSIS = { "analysis" }
KW_AND = { "and" }
KW_AS = { "as" }
KW_ASSERT = { "assert" }
KW_ASSIGN = { "assign" }
KW_ASSOC = { "assoc" }
KW_ASSUME = { "assume" }
KW_AT = { "at" }
KW_ATTRIBUTE = { "attribute" }
KW_BEHAVIOR = { "behavior" }
KW_BIND = { "bind" }
KW_BINDING = { "binding" }
KW_BOOL = { "bool" }
KW_BY = { "by" }
KW_CALC = { "calc" }
KW_CASE = { "case" }
KW_CHAINS = { "chains" }
KW_CLASS = { "class" }
KW_CLASSIFIER = { "classifier" }
KW_COMMENT = { "comment" }
KW_COMPOSITE = { "composite" }
KW_CONCERN = { "concern" }
KW_CONJUGATE = { "conjugate" }
KW_CONJUGATES = { "conjugates" }
KW_CONJUGATION = { "conjugation" }
KW_CONNECT = { "connect" }
KW_CONNECTION = { "connection" }
KW_CONNECTOR = { "connector" }
KW_CONST = { "const" }
KW_CONSTANT = { "constant" }
KW_CONSTRAINT = { "constraint" }
KW_CROSSES = { "crosses" }
KW_DATATYPE = { "datatype" }
KW_DECIDE = { "decide" }
KW_DEF = { "def" }
KW_DEFAULT = { "default" }
KW_DEFINED = { "defined" }
KW_DEPENDENCY = { "dependency" }
KW_DERIVED = { "derived" }
KW_DIFFERENCES = { "differences" }
KW_DISJOINING = { "disjoining" }
KW_DISJOINT = { "disjoint" }
KW_DO = { "do" }
KW_DOC = { "doc" }
KW_ELSE = { "else" }
KW_END = { "end" }
KW_ENTRY = { "entry" }
KW_ENUM = { "enum" }
KW_EVENT = { "event" }
KW_EXHIBIT = { "exhibit" }
KW_EXIT = { "exit" }
KW_EXPOSE = { "expose" }
KW_EXPR = { "expr" }
KW_FALSE = { "false" }
KW_FEATURE = { "feature" }
KW_FEATURED = { "featured" }
KW_FEATURING = { "featuring" }
KW_FILTER = { "filter" }
KW_FIRST = { "first" }
KW_FLOW = { "flow" }
KW_FOR = { "for" }
KW_FORK = { "fork" }
KW_FRAME = { "frame" }
KW_FROM = { "from" }
KW_FUNCTION = { "function" }
KW_HASTYPE = { "hastype" }
KW_IF = { "if" }
KW_IMPLIES = { "implies" }
KW_IMPORT = { "import" }
KW_IN = { "in" }
KW_INCLUDE = { "include" }
KW_INDIVIDUAL = { "individual" }
KW_INOUT = { "inout" }
KW_INTERACTION = { "interaction" }
KW_INTERFACE = { "interface" }
KW_INTERSECTS = { "intersects" }
KW_INV = { "inv" }
KW_INVERSE = { "inverse" }
KW_INVERTING = { "inverting" }
KW_ISTYPE = { "istype" }
KW_ITEM = { "item" }
KW_JOIN = { "join" }
KW_LANGUAGE = { "language" }
KW_LIBRARY = { "library" }
KW_LOCALE = { "locale" }
KW_LOOP = { "loop" }
KW_MEMBER = { "member" }
KW_MERGE = { "merge" }
KW_MESSAGE = { "message" }
KW_META = { "meta" }
KW_METACLASS = { "metaclass" }
KW_METADATA = { "metadata" }
KW_MULTIPLICITY = { "multiplicity" }
KW_NAMESPACE = { "namespace" }
KW_NEW = { "new" }
KW_NONUNIQUE = { "nonunique" }
KW_NOT = { "not" }
KW_NULL = { "null" }
KW_OBJECTIVE = { "objective" }
KW_OCCURRENCE = { "occurrence" }
KW_OF = { "of" }
KW_OR = { "or" }
KW_ORDERED = { "ordered" }
KW_OUT = { "out" }
KW_PACKAGE = { "package" }
KW_PARALLEL = { "parallel" }
KW_PART = { "part" }
KW_PERFORM = { "perform" }
KW_PORT = { "port" }
KW_PORTION = { "portion" }
KW_PREDICATE = { "predicate" }
KW_PRIVATE = { "private" }
KW_PROTECTED = { "protected" }
KW_PUBLIC = { "public" }
KW_READONLY = { "readonly" }
KW_REDEFINES = { "redefines" }
KW_REDEFINITION = { "redefinition" }
KW_REF = { "ref" }
KW_REFERENCES = { "references" }
KW_RENDER = { "render" }
KW_RENDERING = { "rendering" }
KW_REP = { "rep" }
KW_REQUIRE = { "require" }
KW_REQUIREMENT = { "requirement" }
KW_RETURN = { "return" }
KW_SATISFY = { "satisfy" }
KW_SEND = { "send" }
KW_SNAPSHOT = { "snapshot" }
KW_SPECIALIZATION = { "specialization" }
KW_SPECIALIZES = { "specializes" }
KW_STAKEHOLDER = { "stakeholder" }
KW_STANDARD = { "standard" }
KW_STATE = { "state" }
KW_STEP = { "step" }
KW_STRUCT = { "struct" }
KW_SUBCLASSIFIER = { "subclassifier" }
KW_SUBJECT = { "subject" }
KW_SUBSET = { "subset" }
KW_SUBSETS = { "subsets" }
KW_SUBTYPE = { "subtype" }
KW_SUCCESSION = { "succession" }
KW_TERMINATE = { "terminate" }
KW_THEN = { "then" }
KW_TIMESLICE = { "timeslice" }
KW_TO = { "to" }
KW_TRANSITION = { "transition" }
KW_TRUE = { "true" }
KW_TYPE = { "type" }
KW_TYPED = { "typed" }
KW_TYPING = { "typing" }
KW_UNIONS = { "unions" }
KW_UNTIL = { "until" }
KW_USE = { "use" }
KW_VAR = { "var" }
KW_VARIANT = { "variant" }
KW_VARIATION = { "variation" }
KW_VERIFICATION = { "verification" }
KW_VERIFY = { "verify" }
KW_VIA = { "via" }
KW_VIEW = { "view" }
KW_VIEWPOINT = { "viewpoint" }
KW_WHEN = { "when" }
KW_WHILE = { "while" }
KW_XOR = { "xor" }

// =============================================================================
// OPERATORS (Generated from KerMLExpressions.xtext)
// =============================================================================

ConditionalOperator = { KW_IF }
NullCoalescingOperator = { "??" }
ImpliesOperator = { KW_IMPLIES }
OrOperator = { "|" }
ConditionalOrOperator = { KW_OR }
XorOperator = { KW_XOR }
AndOperator = { "&" }
ConditionalAndOperator = { KW_AND }
EqualityOperator = { "===" | "!==" | "==" | "!=" }
ClassificationTestOperator = { KW_HASTYPE | KW_ISTYPE | "@" }
MetaClassificationTestOperator = { "@@" }
CastOperator = { KW_AS }
MetaCastOperator = { KW_META }
RelationalOperator = { "<=" | ">=" | "<" | ">" }
AdditiveOperator = { "+" | "-" }
MultiplicativeOperator = { "*" | "/" | "%" }
ExponentiationOperator = { "**" | "^" }
UnaryOperator = { KW_NOT | "+" | "-" | "~" }

// =============================================================================
// ENUMS (Generated from SysML.xtext)
// =============================================================================

FeatureDirectionKind = { KW_IN | KW_INOUT | KW_OUT }
PortionKind = { KW_SNAPSHOT | KW_TIMESLICE }
RequirementConstraintKind = { KW_ASSUME | KW_FRAME | KW_REQUIRE | KW_VERIFY }
TransitionFeatureKind = { KW_ACCEPT | KW_DO | KW_IF }
VisibilityKind = { KW_EXPOSE | KW_PRIVATE | KW_PROTECTED | KW_PUBLIC }

// =============================================================================
// TOKENS (Composite tokens that reference keywords)
// =============================================================================

// Specialization tokens
SpecializesToken = { ":>" | KW_SPECIALIZES }
SubsetsToken = { ":>" | KW_SUBSETS }
ReferencesToken = { "::>" | KW_REFERENCES }
CrossesToken = { "=>" | KW_CROSSES }
RedefinesToken = { ":>>" | KW_REDEFINES }
TypedByToken = { ":" | (KW_TYPED ~ KW_BY) }
DefinedByToken = { ":" | (KW_DEFINED ~ KW_BY) }
ConjugatesToken = { "~" | KW_CONJUGATES }

// Import kind
ImportKind = { "::*::**" | "::**" | "::*" }

// =============================================================================
// COMMON FRAGMENTS
// =============================================================================

Abstract = { KW_ABSTRACT }
Visibility = { VisibilityKind }
Readonly = { KW_READONLY }
Derived = { KW_DERIVED }
End = { KW_END }
Sufficient = { KW_ALL }
Standard = { KW_STANDARD }
ImportAll = { KW_ALL }
Variation = { KW_VARIATION }
Individual = { KW_INDIVIDUAL }

MultiplicityProperties = {
    (KW_ORDERED ~ KW_NONUNIQUE?)
    | (KW_NONUNIQUE ~ KW_ORDERED?)
}

// =============================================================================
// ENTRY POINT
// =============================================================================

// Main entry point - a file can contain package body elements
File = { SOI ~ PackageBodyElement* ~ EOI }

// Alternative entry point for testing
Model = { SOI ~ PackageBodyElement* ~ EOI }

// =============================================================================
// PACKAGES
// =============================================================================

Package = {
    PrefixMetadata? ~ KW_PACKAGE ~ Identification? ~ PackageBody
}

LibraryPackage = {
    Standard? ~ KW_LIBRARY ~ PrefixMetadata? ~ KW_PACKAGE ~ Identification? ~ PackageBody
}

PackageBody = { ";" | "{" ~ PackageBodyElement* ~ "}" }

PackageBodyElement = {
    Import
    | AliasMember
    | ElementFilterMember
    | AnnotatingMember
    | UsageMember
    | DefinitionMember
    | RelationshipMember
}

// =============================================================================
// IMPORTS
// =============================================================================

Import = {
    ImportPrefix ~ ImportedReference ~ FilterPackage? ~ RelationshipBody
}

ImportPrefix = { Visibility? ~ KW_IMPORT ~ ImportAll? }

ImportedReference = {
    QualifiedName ~ ImportNamespaceMarker? ~ ImportRecursiveMarker?
}

ImportNamespaceMarker = { "::*" }
ImportRecursiveMarker = { "::**" }

FilterPackage = { FilterPackageMember+ }

FilterPackageMember = { "[" ~ OwnedExpression ~ "]" }

// =============================================================================
// MEMBERS
// =============================================================================

AliasMember = {
    Visibility? ~ KW_ALIAS ~ Identification? ~ KW_FOR ~ QualifiedName ~ RelationshipBody
}

ElementFilterMember = {
    Visibility? ~ KW_FILTER ~ OwnedExpression ~ ";"
}

AnnotatingMember = { Visibility? ~ AnnotatingElement }

UsageMember = { Visibility? ~ UsageElement }

DefinitionMember = { Visibility? ~ DefinitionElement }

RelationshipMember = { Visibility? ~ Dependency }

VariantUsageMember = { Visibility? ~ KW_VARIANT ~ VariantUsageElement }

NonOccurrenceUsageMember = { Visibility? ~ NonOccurrenceUsageElement }

OccurrenceUsageMember = { Visibility? ~ OccurrenceUsageElement }

// =============================================================================
// DEFINITIONS
// =============================================================================

DefinitionElement = {
    Package
    | LibraryPackage
    | AttributeDefinition
    | EnumerationDefinition
    | OccurrenceDefinition
    | ItemDefinition
    | MetadataDefinition
    | PartDefinition
    | ConnectionDefinition
    | FlowConnectionDefinition
    | InterfaceDefinition
    | AllocationDefinition
    | PortDefinition
    | ActionDefinition
    | CalculationDefinition
    | StateDefinition
    | ConstraintDefinition
    | RequirementDefinition
    | ConcernDefinition
    | CaseDefinition
    | AnalysisCaseDefinition
    | VerificationCaseDefinition
    | UseCaseDefinition
    | ViewDefinition
    | ViewpointDefinition
    | RenderingDefinition
    | ExtendedDefinition
}

DefinitionPrefix = { BasicDefinitionPrefix? ~ DefinitionExtensionKeyword* }
BasicDefinitionPrefix = { Abstract | Variation }
DefinitionExtensionKeyword = { PrefixMetadataMember }

DefinitionDeclaration = { Identification? ~ SubclassificationPart? }

DefinitionBody = { ";" | "{" ~ DefinitionBodyItem* ~ "}" }

DefinitionBodyItem = {
    Import
    | AliasMember
    | AnnotatingMember
    | RelationshipMember
    | DefinitionMember
    | VariantUsageMember
    | NonOccurrenceUsageMember
    | OccurrenceUsageMember
}

// Subclassification
SubclassificationPart = {
    SpecializesToken ~ OwnedSubclassification ~ ("," ~ OwnedSubclassification)*
}

OwnedSubclassification = { QualifiedName }

// Specific definitions
AttributeDefinition = {
    DefinitionPrefix ~ KW_ATTRIBUTE ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

EnumerationDefinition = {
    PrefixMetadata? ~ KW_ENUM ~ KW_DEF ~ DefinitionDeclaration ~ EnumerationBody
}

EnumerationBody = { ";" | "{" ~ EnumerationBodyItem* ~ "}" }

EnumerationBodyItem = {
    AnnotatingMember
    | EnumerationUsageMember
}

EnumerationUsageMember = { Visibility? ~ EnumeratedValue }

EnumeratedValue = { PrefixMetadata? ~ KW_ENUM? ~ UsageDeclaration? ~ UsageCompletion }

OccurrenceDefinition = {
    OccurrenceDefinitionPrefix ~ KW_OCCURRENCE ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

OccurrenceDefinitionPrefix = {
    BasicDefinitionPrefix? ~ Individual? ~ DefinitionExtensionKeyword*
}

ItemDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ITEM ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

MetadataDefinition = {
    Abstract? ~ PrefixMetadata? ~ KW_METADATA ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

PartDefinition = {
    OccurrenceDefinitionPrefix ~ KW_PART ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

PortDefinition = {
    DefinitionPrefix ~ KW_PORT ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ConnectionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONNECTION ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

FlowConnectionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_FLOW ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

InterfaceDefinition = {
    OccurrenceDefinitionPrefix ~ KW_INTERFACE ~ KW_DEF ~ DefinitionDeclaration ~ InterfaceBody
}

InterfaceBody = { ";" | "{" ~ InterfaceBodyItem* ~ "}" }

InterfaceBodyItem = { DefinitionBodyItem }

AllocationDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ALLOCATION ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ActionDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ACTION ~ KW_DEF ~ DefinitionDeclaration ~ ActionBody
}

ActionBody = { ";" | "{" ~ ActionBodyItem* ~ "}" }

ActionBodyItem = {
    DefinitionBodyItem
    | InitialNodeMember
    | ControlNodeMember
    | ActionNodeMember
}

InitialNodeMember = { Visibility? ~ KW_FIRST ~ QualifiedName ~ RelationshipBody }

ControlNodeMember = { Visibility? ~ ControlNode }

ActionNodeMember = { Visibility? ~ ActionNode }

StateDefinition = {
    OccurrenceDefinitionPrefix ~ KW_STATE ~ KW_DEF ~ DefinitionDeclaration ~ StateBody
}

StateBody = { ";" | KW_PARALLEL? ~ "{" ~ StateBodyItem* ~ "}" }

StateBodyItem = {
    DefinitionBodyItem
    | EntryActionMember
    | DoActionMember
    | ExitActionMember
    | TransitionUsageMember
}

EntryActionMember = { Visibility? ~ KW_ENTRY ~ StateActionUsage }
DoActionMember = { Visibility? ~ KW_DO ~ StateActionUsage }
ExitActionMember = { Visibility? ~ KW_EXIT ~ StateActionUsage }

StateActionUsage = { ";" | UsageDeclaration? ~ ActionBody }

TransitionUsageMember = { Visibility? ~ TransitionUsage }

CalculationDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CALC ~ KW_DEF ~ DefinitionDeclaration ~ CalculationBody
}

CalculationBody = { ";" | "{" ~ CalculationBodyItem* ~ ResultExpressionMember? ~ "}" }

CalculationBodyItem = {
    ActionBodyItem
    | ReturnParameterMember
}

ReturnParameterMember = { Visibility? ~ KW_RETURN ~ UsageElement }

ResultExpressionMember = { Visibility? ~ OwnedExpression }

ConstraintDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONSTRAINT ~ KW_DEF ~ DefinitionDeclaration ~ CalculationBody
}

RequirementDefinition = {
    OccurrenceDefinitionPrefix ~ KW_REQUIREMENT ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

RequirementBody = { ";" | "{" ~ RequirementBodyItem* ~ "}" }

RequirementBodyItem = {
    DefinitionBodyItem
    | SubjectMember
    | RequirementConstraintMember
    | ActorMember
    | StakeholderMember
}

SubjectMember = { Visibility? ~ KW_SUBJECT ~ SubjectUsage }
SubjectUsage = { UsageDeclaration? ~ UsageCompletion }

RequirementConstraintMember = {
    Visibility? ~ RequirementConstraintKind ~ RequirementConstraintUsage
}
// Note: RequirementConstraintKind is generated from xtext enums
RequirementConstraintUsage = {
    OwnedReferenceSubsetting ~ FeatureSpecialization* ~ CalculationBody
    | UsageDeclaration? ~ CalculationBody
}

ActorMember = { Visibility? ~ KW_ACTOR ~ ActorUsage }
ActorUsage = { UsageDeclaration? ~ UsageCompletion }

StakeholderMember = { Visibility? ~ KW_STAKEHOLDER ~ StakeholderUsage }
StakeholderUsage = { UsageDeclaration? ~ UsageCompletion }

ConcernDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CONCERN ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

CaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_CASE ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

CaseBody = { ";" | "{" ~ CaseBodyItem* ~ ResultExpressionMember? ~ "}" }

CaseBodyItem = {
    CalculationBodyItem
    | SubjectMember
    | ActorMember
    | ObjectiveMember
}

ObjectiveMember = { Visibility? ~ KW_OBJECTIVE ~ ObjectiveRequirementUsage }
ObjectiveRequirementUsage = { UsageDeclaration? ~ RequirementBody }

AnalysisCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_ANALYSIS ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

VerificationCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VERIFICATION ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

UseCaseDefinition = {
    OccurrenceDefinitionPrefix ~ KW_USE ~ KW_CASE ~ KW_DEF ~ DefinitionDeclaration ~ CaseBody
}

ViewDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VIEW ~ KW_DEF ~ DefinitionDeclaration ~ ViewBody
}

ViewBody = { ";" | "{" ~ ViewBodyItem* ~ "}" }

ViewBodyItem = {
    DefinitionBodyItem
    | ElementFilterMember
    | ViewRenderingMember
}

ViewRenderingMember = { Visibility? ~ KW_RENDER ~ ViewRenderingUsage }
ViewRenderingUsage = {
    OwnedReferenceSubsetting ~ FeatureSpecialization* ~ UsageBody
    | UsageDeclaration? ~ UsageCompletion
}

ViewpointDefinition = {
    OccurrenceDefinitionPrefix ~ KW_VIEWPOINT ~ KW_DEF ~ DefinitionDeclaration ~ RequirementBody
}

RenderingDefinition = {
    OccurrenceDefinitionPrefix ~ KW_RENDERING ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

ExtendedDefinition = {
    BasicDefinitionPrefix? ~ DefinitionExtensionKeyword+ ~ KW_DEF ~ DefinitionDeclaration ~ DefinitionBody
}

// =============================================================================
// USAGES
// =============================================================================

UsageElement = {
    NonOccurrenceUsageElement
    | OccurrenceUsageElement
}

NonOccurrenceUsageElement = {
    ReferenceUsage
    | AttributeUsage
    | EnumerationUsage
    | BindingConnectorAsUsage
    | SuccessionAsUsage
    | ExtendedUsage
}

OccurrenceUsageElement = {
    StructureUsageElement
    | BehaviorUsageElement
}

StructureUsageElement = {
    OccurrenceUsage
    | IndividualUsage
    | PortionUsage
    | EventOccurrenceUsage
    | ItemUsage
    | PartUsage
    | PortUsage
    | ConnectionUsage
    | InterfaceUsage
    | AllocationUsage
    | FlowConnectionUsage
    | ViewUsage
    | RenderingUsage
}

BehaviorUsageElement = {
    ActionUsage
    | CalculationUsage
    | StateUsage
    | ConstraintUsage
    | RequirementUsage
    | ConcernUsage
    | CaseUsage
    | AnalysisCaseUsage
    | VerificationCaseUsage
    | UseCaseUsage
    | ViewpointUsage
    | PerformActionUsage
    | ExhibitStateUsage
    | IncludeUseCaseUsage
    | AssertConstraintUsage
    | SatisfyRequirementUsage
}

VariantUsageElement = {
    VariantReference
    | NonOccurrenceUsageElement
    | OccurrenceUsageElement
}

VariantReference = { OwnedReferenceSubsetting ~ FeatureSpecialization* ~ UsageBody }

// Usage prefixes
UsagePrefix = { UnextendedUsagePrefix ~ UsageExtensionKeyword* }
UnextendedUsagePrefix = { EndUsagePrefix | BasicUsagePrefix }
BasicUsagePrefix = { RefPrefix ~ Reference? }
RefPrefix = { FeatureDirectionKind? ~ BasicDefinitionPrefix? ~ Readonly? ~ Derived? }
Reference = { KW_REF }
EndUsagePrefix = { End ~ OwnedCrossingFeatureMember? }
UsageExtensionKeyword = { PrefixMetadataMember }
OwnedCrossingFeatureMember = { OwnedCrossingFeature }
OwnedCrossingFeature = { BasicUsagePrefix? ~ UsageDeclaration }

UsageDeclaration = { FeatureDeclaration }

UsageCompletion = { ValuePart? ~ UsageBody }

UsageBody = { DefinitionBody }

// Specific usages
ReferenceUsage = {
    (EndUsagePrefix | RefPrefix) ~ KW_REF ~ UsageDeclaration? ~ UsageCompletion
}

DefaultReferenceUsage = {
    End? ~ RefPrefix ~ UsageDeclaration? ~ UsageCompletion
}

AttributeUsage = {
    UsagePrefix ~ KW_ATTRIBUTE ~ UsageDeclaration? ~ UsageCompletion
}

EnumerationUsage = {
    UsagePrefix ~ KW_ENUM ~ UsageDeclaration? ~ UsageCompletion
}

OccurrenceUsage = {
    OccurrenceUsagePrefix ~ KW_OCCURRENCE ~ UsageDeclaration? ~ UsageCompletion
}

OccurrenceUsagePrefix = {
    (EndUsagePrefix | BasicOccurrenceUsagePrefix) ~ UsageExtensionKeyword*
}

BasicOccurrenceUsagePrefix = { BasicUsagePrefix ~ Individual? ~ Portion? }

Portion = { PortionKind }

IndividualUsage = {
    BasicUsagePrefix ~ Individual ~ UsageExtensionKeyword* ~ UsageDeclaration? ~ UsageCompletion
}

PortionUsage = {
    BasicUsagePrefix ~ Individual? ~ Portion ~ UsageExtensionKeyword* ~ UsageDeclaration? ~ UsageCompletion
}

EventOccurrenceUsage = {
    OccurrenceUsagePrefix ~ KW_EVENT ~ (
        OwnedReferenceSubsetting ~ FeatureSpecializationPart?
        | KW_OCCURRENCE ~ UsageDeclaration?
    ) ~ UsageCompletion
}

ItemUsage = {
    OccurrenceUsagePrefix ~ KW_ITEM ~ UsageDeclaration? ~ UsageCompletion
}

PartUsage = {
    OccurrenceUsagePrefix ~ KW_PART ~ UsageDeclaration? ~ UsageCompletion
}

PortUsage = {
    OccurrenceUsagePrefix ~ KW_PORT ~ UsageDeclaration? ~ UsageCompletion
}

ConnectionUsage = {
    OccurrenceUsagePrefix ~ (
        KW_CONNECTION ~ UsageDeclaration? ~ ValuePart? ~ (KW_CONNECT ~ ConnectorPart)?
        | KW_CONNECT ~ ConnectorPart
    ) ~ UsageBody
}

ConnectorPart = { BinaryConnectorPart | NaryConnectorPart }

BinaryConnectorPart = { ConnectorEndMember ~ KW_TO ~ ConnectorEndMember }

NaryConnectorPart = { "(" ~ ConnectorEndMember ~ ("," ~ ConnectorEndMember)+ ~ ")" }

ConnectorEndMember = { ConnectorEnd }

ConnectorEnd = {
    OwnedCrossMultiplicityMember? ~ (RegularName ~ ReferencesToken)? ~ OwnedReferenceSubsetting
}

OwnedCrossMultiplicityMember = { OwnedCrossMultiplicity }

OwnedCrossMultiplicity = { OwnedMultiplicity }

InterfaceUsage = {
    OccurrenceUsagePrefix ~ KW_INTERFACE ~ UsageDeclaration? ~ (KW_CONNECT ~ InterfacePart)? ~ InterfaceBody
}

InterfacePart = { BinaryInterfacePart | NaryInterfacePart }

BinaryInterfacePart = { InterfaceEndMember ~ KW_TO ~ InterfaceEndMember }

NaryInterfacePart = { "(" ~ InterfaceEndMember ~ ("," ~ InterfaceEndMember)+ ~ ")" }

InterfaceEndMember = { InterfaceEnd }

InterfaceEnd = {
    OwnedCrossMultiplicityMember? ~ (RegularName ~ ReferencesToken)? ~ OwnedReferenceSubsetting
}

AllocationUsage = {
    OccurrenceUsagePrefix ~ (
        KW_ALLOCATION ~ UsageDeclaration? ~ (KW_ALLOCATE ~ ConnectorPart)?
        | KW_ALLOCATE ~ ConnectorPart
    ) ~ UsageBody
}

FlowConnectionUsage = {
    OccurrenceUsagePrefix ~ KW_FLOW ~ FlowConnectionDeclaration ~ DefinitionBody
}

FlowConnectionDeclaration = {
    FlowEndMember ~ KW_TO ~ FlowEndMember
    | UsageDeclaration? ~ ValuePart? ~ (KW_OF ~ ItemFeatureMember)? ~
        (KW_FROM ~ FlowEndMember ~ KW_TO ~ FlowEndMember)?
}

ItemFeatureMember = { ItemFeature }

ItemFeature = {
    Identification? ~ PayloadFeatureSpecializationPart ~ ValuePart?
    | Identification? ~ ValuePart
    | OwnedFeatureTyping ~ OwnedMultiplicity?
    | OwnedMultiplicity ~ OwnedFeatureTyping
}

PayloadFeatureSpecializationPart = {
    FeatureSpecialization+ ~ (MultiplicityPart ~ FeatureSpecialization*)?
    | MultiplicityPart ~ FeatureSpecialization+
}

FlowEndMember = { FlowEnd }

FlowEnd = { FlowEndSubsetting? ~ FlowFeatureMember }

FlowEndSubsetting = { QualifiedName ~ "." | FeatureChainPrefix }

FlowFeatureMember = { FlowFeature }

FlowFeature = { FlowRedefinition }

FlowRedefinition = { QualifiedName }

ViewUsage = {
    OccurrenceUsagePrefix ~ KW_VIEW ~ UsageDeclaration? ~ ValuePart? ~ ViewBody
}

RenderingUsage = {
    OccurrenceUsagePrefix ~ KW_RENDERING ~ UsageDeclaration? ~ UsageCompletion
}

ActionUsage = {
    OccurrenceUsagePrefix ~ KW_ACTION ~ UsageDeclaration? ~ ValuePart? ~ ActionBody
}

PerformActionUsage = {
    OccurrenceUsagePrefix ~ KW_PERFORM ~ (
        OwnedReferenceSubsetting ~ FeatureSpecializationPart?
        | KW_ACTION ~ UsageDeclaration?
    ) ~ ValuePart? ~ ActionBody
}

CalculationUsage = {
    OccurrenceUsagePrefix ~ KW_CALC ~ UsageDeclaration? ~ ValuePart? ~ CalculationBody
}

StateUsage = {
    OccurrenceUsagePrefix ~ KW_STATE ~ UsageDeclaration? ~ ValuePart? ~ StateBody
}

ExhibitStateUsage = {
    OccurrenceUsagePrefix ~ KW_EXHIBIT ~ (
        OwnedReferenceSubsetting ~ FeatureSpecializationPart?
        | KW_STATE ~ UsageDeclaration?
    ) ~ ValuePart? ~ StateBody
}

ConstraintUsage = {
    OccurrenceUsagePrefix ~ KW_CONSTRAINT ~ UsageDeclaration? ~ ValuePart? ~ CalculationBody
}

AssertConstraintUsage = {
    OccurrenceUsagePrefix ~ KW_ASSERT ~ KW_NOT? ~ (
        OwnedReferenceSubsetting ~ FeatureSpecializationPart?
        | KW_CONSTRAINT ~ UsageDeclaration? ~ ValuePart?
    ) ~ CalculationBody
}

RequirementUsage = {
    OccurrenceUsagePrefix ~ KW_REQUIREMENT ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

SatisfyRequirementUsage = {
    OccurrenceUsagePrefix ~ KW_ASSERT? ~ KW_NOT? ~ KW_SATISFY ~ (
        OwnedReferenceSubsetting ~ FeatureSpecializationPart?
        | KW_REQUIREMENT ~ UsageDeclaration?
    ) ~ ValuePart? ~ (KW_BY ~ SatisfactionSubjectMember)? ~ RequirementBody
}

SatisfactionSubjectMember = { SatisfactionParameter }

SatisfactionParameter = { SatisfactionFeatureValue }

SatisfactionFeatureValue = { OwnedExpression }

ConcernUsage = {
    OccurrenceUsagePrefix ~ KW_CONCERN ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

CaseUsage = {
    OccurrenceUsagePrefix ~ KW_CASE ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

AnalysisCaseUsage = {
    OccurrenceUsagePrefix ~ KW_ANALYSIS ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

VerificationCaseUsage = {
    OccurrenceUsagePrefix ~ KW_VERIFICATION ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

UseCaseUsage = {
    OccurrenceUsagePrefix ~ KW_USE ~ KW_CASE ~ UsageDeclaration? ~ ValuePart? ~ CaseBody
}

IncludeUseCaseUsage = {
    OccurrenceUsagePrefix ~ KW_INCLUDE ~ (
        OwnedReferenceSubsetting ~ FeatureSpecializationPart?
        | KW_USE ~ KW_CASE ~ UsageDeclaration?
    ) ~ ValuePart? ~ CaseBody
}

ViewpointUsage = {
    OccurrenceUsagePrefix ~ KW_VIEWPOINT ~ UsageDeclaration? ~ ValuePart? ~ RequirementBody
}

BindingConnectorAsUsage = {
    UsagePrefix ~ (KW_BINDING ~ UsageDeclaration?)? ~
    KW_BIND ~ ConnectorEndMember ~ "=" ~ ConnectorEndMember ~ DefinitionBody
}

SuccessionAsUsage = {
    UsagePrefix ~ (KW_SUCCESSION ~ UsageDeclaration?)? ~
    KW_FIRST ~ ConnectorEndMember ~ KW_THEN ~ ConnectorEndMember ~ DefinitionBody
}

ExtendedUsage = {
    UnextendedUsagePrefix ~ UsageExtensionKeyword+ ~ UsageDeclaration? ~ UsageCompletion
}

// =============================================================================
// FEATURES
// =============================================================================

FeatureDeclaration = {
    Identification ~ FeatureSpecializationPart?
    | FeatureSpecializationPart
}

FeatureSpecializationPart = {
    FeatureSpecialization+ ~ (MultiplicityPart ~ FeatureSpecialization*)?
    | MultiplicityPart ~ FeatureSpecialization*
}

FeatureSpecialization = {
    Typings
    | Subsettings
    | References_
    | Crosses
    | Redefinitions
}

Typings = { TypedBy ~ ("," ~ FeatureTyping)* }

TypedBy = { DefinedByToken ~ FeatureTyping }

FeatureTyping = { OwnedFeatureTyping | ConjugatedPortTyping }

OwnedFeatureTyping = { FeatureType }

FeatureType = { QualifiedName | OwnedFeatureChain }

ConjugatedPortTyping = { "~" ~ QualifiedName }

Subsettings = { Subsets ~ ("," ~ OwnedSubsetting)* }

Subsets = { SubsetsToken ~ OwnedSubsetting }

OwnedSubsetting = { QualifiedName | OwnedFeatureChain }

References_ = { ReferencesToken ~ OwnedReferenceSubsetting }

OwnedReferenceSubsetting = { QualifiedName | OwnedFeatureChain }

Crosses = { CrossesToken ~ OwnedCrossSubsetting }

OwnedCrossSubsetting = { QualifiedName | OwnedFeatureChain }

Redefinitions = { Redefines ~ ("," ~ OwnedRedefinition)* }

Redefines = { RedefinesToken ~ OwnedRedefinition }

OwnedRedefinition = { QualifiedName | OwnedFeatureChain }

// Feature chains
OwnedFeatureChain = { FeatureChain }

FeatureChain = { OwnedFeatureChaining ~ ("." ~ OwnedFeatureChaining)+ }

FeatureChainPrefix = { (OwnedFeatureChaining ~ ".")+ ~ OwnedFeatureChaining ~ "." }

OwnedFeatureChaining = { QualifiedName }

// Multiplicity
MultiplicityPart = {
    OwnedMultiplicity ~ MultiplicityProperties?
    | MultiplicityProperties
}

OwnedMultiplicity = { MultiplicityRange }

MultiplicityRange = { "[" ~ MultiplicityExpressionMember ~ "]" }

MultiplicityExpressionMember = { OwnedExpression }

// Value part
ValuePart = { FeatureValue }

FeatureValue = {
    ("=" | ":=" | (KW_DEFAULT ~ ("=" | ":=")?)) ~ OwnedExpression
}

// =============================================================================
// ANNOTATIONS
// =============================================================================

AnnotatingElement = {
    Comment
    | Documentation
    | TextualRepresentation
    | MetadataUsage
}

Comment = {
    (KW_COMMENT ~ Identification? ~ (KW_ABOUT ~ Annotation ~ ("," ~ Annotation)*)?)? ~
    (KW_LOCALE ~ STRING_VALUE)? ~
    REGULAR_COMMENT_BODY
}

Documentation = {
    KW_DOC ~ Identification? ~
    (KW_LOCALE ~ STRING_VALUE)? ~
    REGULAR_COMMENT_BODY
}

TextualRepresentation = {
    (KW_REP ~ Identification?)? ~ KW_LANGUAGE ~ STRING_VALUE ~ REGULAR_COMMENT_BODY
}

Annotation = { QualifiedName }

// Metadata
PrefixMetadata = { PrefixMetadataMember+ }

PrefixMetadataMember = { PrefixMetadataUsage }

PrefixMetadataUsage = { "#" ~ MetadataTyping }

MetadataTyping = { QualifiedName }

MetadataUsage = {
    PrefixMetadata? ~ (KW_METADATA | "@") ~ MetadataUsageDeclaration ~
    (KW_ABOUT ~ Annotation ~ ("," ~ Annotation)*)? ~
    MetadataBody
}

MetadataUsageDeclaration = { (Identification? ~ DefinedByToken)? ~ MetadataTyping }

MetadataBody = { ";" | "{" ~ MetadataBodyItem* ~ "}" }

MetadataBodyItem = {
    DefinitionMember
    | RelationshipMember
    | AnnotatingMember
    | MetadataBodyUsageMember
    | AliasMember
    | Import
}

MetadataBodyUsageMember = { MetadataBodyUsage }

MetadataBodyUsage = {
    KW_REF? ~ RedefinesToken? ~ OwnedRedefinition ~
    FeatureSpecializationPart? ~ ValuePart? ~ MetadataBody
}

// =============================================================================
// RELATIONSHIPS (Dependencies)
// =============================================================================

Dependency = {
    PrefixMetadataAnnotation* ~ KW_DEPENDENCY ~ (Identification? ~ KW_FROM)? ~
    QualifiedName ~ ("," ~ QualifiedName)* ~ KW_TO ~
    QualifiedName ~ ("," ~ QualifiedName)* ~
    RelationshipBody
}

PrefixMetadataAnnotation = { PrefixMetadataUsage }

RelationshipBody = { ";" | "{" ~ RelationshipBodyElement* ~ "}" }

RelationshipBodyElement = { AnnotatingMember }

// =============================================================================
// ACTION NODES
// =============================================================================

ActionNode = {
    SendNode
    | AcceptNode
    | AssignmentNode
    | TerminateNode
    | IfNode
    | WhileLoopNode
    | ForLoopNode
    | ControlNode
}

ActionNodePrefix = { OccurrenceUsagePrefix ~ ActionNodeUsageDeclaration? }

ActionNodeUsageDeclaration = { KW_ACTION ~ UsageDeclaration? }

SendNode = {
    OccurrenceUsagePrefix ~ ActionNodeUsageDeclaration? ~
    KW_SEND ~ NodeParameterMember ~
    (KW_VIA ~ NodeParameterMember)? ~
    (KW_TO ~ NodeParameterMember)? ~
    ActionBody
}

AcceptNode = {
    OccurrenceUsagePrefix ~ ActionNodeUsageDeclaration? ~
    KW_ACCEPT ~ AcceptParameterPart ~ ActionBody
}

AcceptParameterPart = {
    PayloadParameterMember ~ (KW_VIA ~ NodeParameterMember)?
}

PayloadParameterMember = { PayloadParameter }

PayloadParameter = {
    Identification? ~ TriggerValuePart
    | Identification? ~ PayloadFeatureSpecializationPart ~ ValuePart?
    | Identification ~ ValuePart?
}

TriggerValuePart = { TriggerFeatureValue }

TriggerFeatureValue = { TriggerExpression }

TriggerExpression = {
    TriggerKind ~ ArgumentMember
}

TriggerKind = { KW_AT | KW_AFTER | KW_WHEN }

NodeParameterMember = { NodeParameter }

NodeParameter = { FeatureBinding }

FeatureBinding = { OwnedExpression }

AssignmentNode = {
    OccurrenceUsagePrefix ~ ActionNodeUsageDeclaration? ~
    KW_ASSIGN ~ FeatureChainMember ~ ":=" ~ NodeParameterMember ~ ActionBody
}

FeatureChainMember = { QualifiedName | OwnedFeatureChain }

TerminateNode = {
    ActionNodePrefix ~ KW_TERMINATE ~ NodeParameterMember? ~ ActionBody
}

IfNode = {
    ActionNodePrefix ~ KW_IF ~ ExpressionParameterMember ~
    ActionBodyParameterMember ~
    (KW_ELSE ~ (ActionBodyParameterMember | IfNodeParameterMember))?
}

ExpressionParameterMember = { OwnedExpression }

ActionBodyParameterMember = { ActionBodyParameter }

ActionBodyParameter = { (KW_ACTION ~ UsageDeclaration?)? ~ "{" ~ ActionBodyItem* ~ "}" }

IfNodeParameterMember = { IfNode }

WhileLoopNode = {
    ActionNodePrefix ~ (
        KW_WHILE ~ ExpressionParameterMember
        | KW_LOOP
    ) ~ ActionBodyParameterMember ~
    (KW_UNTIL ~ ExpressionParameterMember ~ ";")?
}

ForLoopNode = {
    ActionNodePrefix ~ KW_FOR ~ ForVariableDeclarationMember ~
    KW_IN ~ NodeParameterMember ~ ActionBodyParameterMember
}

ForVariableDeclarationMember = { ForVariableDeclaration }

ForVariableDeclaration = { UsageDeclaration }

ControlNode = { MergeNode | DecisionNode | JoinNode | ForkNode }

ControlNodePrefix = { RefPrefix ~ Individual? ~ Portion? ~ PrefixMetadata? }

MergeNode = { ControlNodePrefix ~ KW_MERGE ~ UsageDeclaration? ~ ActionNodeBody }

DecisionNode = { ControlNodePrefix ~ KW_DECIDE ~ UsageDeclaration? ~ ActionNodeBody }

JoinNode = { ControlNodePrefix ~ KW_JOIN ~ UsageDeclaration? ~ ActionNodeBody }

ForkNode = { ControlNodePrefix ~ KW_FORK ~ UsageDeclaration? ~ ActionNodeBody }

ActionNodeBody = { ";" | "{" ~ AnnotatingMember* ~ "}" }

// =============================================================================
// TRANSITIONS
// =============================================================================

TransitionUsage = {
    KW_TRANSITION ~ (UsageDeclaration? ~ KW_FIRST)? ~
    TransitionSourceMember ~
    TriggerActionMember? ~
    GuardExpressionMember? ~
    EffectBehaviorMember? ~
    KW_THEN ~ TransitionSuccessionMember ~
    ActionBody
}

TransitionSourceMember = { QualifiedName | OwnedFeatureChain }

TriggerActionMember = { KW_ACCEPT ~ TriggerAction }

TriggerAction = { AcceptParameterPart }

GuardExpressionMember = { KW_IF ~ OwnedExpression }

EffectBehaviorMember = { KW_DO ~ EffectBehaviorUsage }

EffectBehaviorUsage = {
    UsageDeclaration? ~ ("{" ~ ActionBodyItem* ~ "}")?
}

TransitionSuccessionMember = { TransitionSuccession }

TransitionSuccession = { ConnectorEndMember }

// =============================================================================
// EXPRESSIONS
// =============================================================================

OwnedExpression = { ConditionalExpression }

OwnedExpressionMember = { OwnedExpression }

OwnedExpressionReference = { OwnedExpressionMember }

// Conditional Expressions
ConditionalExpression = {
    NullCoalescingExpression
    | ConcreteConditionalExpression
}

ConcreteConditionalExpression = {
    KW_IF ~ NullCoalescingExpression ~ "?" ~ OwnedExpressionReference ~
    KW_ELSE ~ OwnedExpressionReference
}

NullCoalescingExpression = {
    ImpliesExpression ~ ("??" ~ ImpliesExpressionReference)*
}

ImpliesExpressionReference = { ImpliesExpressionMember }

ImpliesExpressionMember = { ImpliesExpression }

// Logical Expressions
ImpliesExpression = {
    OrExpression ~ (KW_IMPLIES ~ OrExpressionReference)*
}

OrExpressionReference = { OrExpressionMember }

OrExpressionMember = { OrExpression }

OrExpression = {
    XorExpression ~ (("|" ~ XorExpression) | (KW_OR ~ XorExpressionReference))*
}

XorExpressionReference = { XorExpressionMember }

XorExpressionMember = { XorExpression }

XorExpression = {
    AndExpression ~ (KW_XOR ~ AndExpression)*
}

AndExpression = {
    EqualityExpression ~ (("&" ~ EqualityExpression) | (KW_AND ~ EqualityExpressionReference))*
}

EqualityExpressionReference = { EqualityExpressionMember }

EqualityExpressionMember = { EqualityExpression }

// Equality Expressions
EqualityExpression = {
    ClassificationExpression ~ (EqualityOperator ~ ClassificationExpression)*
}

// Classification Expressions
ClassificationExpression = {
    RelationalExpression ~ (
        (ClassificationTestOperator ~ TypeReferenceMember)
        | (KW_AS ~ TypeResultMember)
    )?
    | ClassificationTestOperator ~ TypeReferenceMember
    | MetadataReference ~ "@@" ~ TypeReferenceMember
    | KW_AS ~ TypeResultMember
    | MetadataReference ~ KW_META ~ TypeResultMember
}

TypeReferenceMember = { TypeReferenceFeature }

TypeResultMember = { TypeReferenceFeature }

TypeReferenceFeature = { ReferenceTyping }

ReferenceTyping = { QualifiedName }

MetadataReference = { QualifiedName }

// Relational Expressions
RelationalExpression = {
    RangeExpression ~ (RelationalOperator ~ RangeExpression)*
}

// Range Expressions
RangeExpression = {
    AdditiveExpression ~ (".." ~ AdditiveExpression)?
}

// Arithmetic Expressions
AdditiveExpression = {
    MultiplicativeExpression ~ (("+" | "-") ~ MultiplicativeExpression)*
}

MultiplicativeExpression = {
    ExponentiationExpression ~ (("*" | "/" | "%") ~ ExponentiationExpression)*
}

ExponentiationExpression = {
    UnaryExpression ~ (("**" | "^") ~ ExponentiationExpression)?
}

// Unary Expressions
UnaryExpression = {
    UnaryOperator ~ ExtentExpression
    | ExtentExpression
}

// Extent Expressions
ExtentExpression = {
    KW_ALL ~ TypeResultMember
    | PrimaryExpression
}

// Primary Expressions
PrimaryExpression = {
    BaseExpression ~
    ("." ~ FeatureChainMember)? ~
    (
        ("#" ~ "(" ~ SequenceExpression ~ ")")
        | ("[" ~ SequenceExpression ~ "]")
        | ("->" ~ ReferenceTyping ~ (ExpressionBodyMember | FunctionReferenceMember | ArgumentList))
        | ("." ~ ExpressionBodyMember)
        | (".?" ~ ExpressionBodyMember)
    )* ~
    ("." ~ FeatureChainMember)?
}

// Base Expressions
BaseExpression = {
    NullExpression
    | LiteralExpression
    | FeatureReferenceExpression
    | MetadataAccessExpression
    | InvocationExpression
    | BodyExpression
    | "(" ~ SequenceExpression ~ ")"
}

// Null Expressions
NullExpression = { KW_NULL | "(" ~ ")" }

// Literal Expressions
LiteralExpression = {
    LiteralBoolean
    | LiteralString
    | LiteralNumber
    | LiteralInfinity
}

LiteralBoolean = { KW_TRUE | KW_FALSE }

LiteralString = { STRING_VALUE }

LiteralNumber = { NUMBER }

LiteralInfinity = { "*" }

// Feature Reference Expressions
FeatureReferenceExpression = { FeatureReferenceMember }

FeatureReferenceMember = { QualifiedName }

// Metadata Access Expressions
MetadataAccessExpression = { QualifiedName ~ "." ~ KW_METADATA }

// Invocation Expressions
InvocationExpression = { OwnedFeatureTyping ~ ArgumentList }

ArgumentList = { "(" ~ (PositionalArgumentList | NamedArgumentList)? ~ ")" }

PositionalArgumentList = { ArgumentMember ~ ("," ~ ArgumentMember)* }

ArgumentMember = { Argument }

Argument = { ArgumentValue }

ArgumentValue = { OwnedExpression }

NamedArgumentList = { NamedArgumentMember ~ ("," ~ NamedArgumentMember)* }

NamedArgumentMember = { NamedArgument }

NamedArgument = { ParameterRedefinition ~ "=" ~ ArgumentValue }

ParameterRedefinition = { QualifiedName }

// Body Expressions
BodyExpression = { ExpressionBodyMember }

ExpressionBodyMember = { ExpressionBody }

ExpressionBody = { "{" ~ CalculationBodyItem* ~ ResultExpressionMember? ~ "}" }

// Function Reference
FunctionReferenceMember = { FunctionReference }

FunctionReference = { ReferenceTyping }

// Sequence Expressions
SequenceExpression = {
    OwnedExpression ~ (("," ~ SequenceExpression) | ",")?
}